---
title: "Microarray Pipeline"
author: "Ameek Bhalla"
editor_options:
  chunk_output_type: console
output:
  html_notebook:
    number_sections: yes
    theme: readable
    toc: yes
    toc_depth: '2'
    toc_float: yes
  html_document:
    df_print: paged
    number_sections: yes
    theme: readable
    toc: yes
    toc_depth: '2'
    toc_float: yes
bibliography: Microarray references.bib
---

***

# Useful commands

* Insert a link: `[R Markdown](http://rmarkdown.rstudio.com)`
* Insert a new chunk: `Ctrl+Alt+I`
* Execute a code chunk: `Ctrl+Shift+Enter`
* Preview the html file: `Ctrl+Shift+K`
* Install Bioconductor
+ quietly check if Bioconductor is already installed
   `if(!requireNamespace("BiocManager", quietly = TRUE))`
+ install Bioconductor if not in Namespace:
    `install.packages("BiocManager")` 
* Install a Bioconductor package:`BiocManager::install("package.name")`

# Setup

## Set default chunk options

The default chunk options can be set in the first chunk itself. Later, the behaviour of individuals chunks can be modified by modifying a specific argument.

```{r}
knitr::opts_chunk$set(results = "hide", 
                      tidy = TRUE)
```

## Load Packages

```{r results = "hide"}
library(affy) # Bioconductor package for analysis of older Affymetrix arrays
#library(affyio)
#library(affyPLM)
#library(annaffy)
#library(annotate)
#library(arrayQualityMetrics)
library(BiocManager)
library(drosophila2.db) # annotation package for the model organism
library(drosophila2cdf)
library(formatR)
library(gcrma)
library(htmltools)
library(knitr)
library(limma)
#library(markdown)
library(rmarkdown)
#library(simpleaffy)
library(tidyverse)
```

# Importing data into R

## Importing CEL files into R

In 3' IVT arrays, the probe set matches the 600bp region adjacent to the 3' end of a transcript. 
This is because 3' IVT assays use oligo-dT primers during the cDNA step. 
This causes preferntial amplification of the 3' region adjacent to poly(A) tail of the mRNA. 
3' IVT assays are most commonly used for whole-genome transcriptome experiments. In the newer, exon arrays, the probe sets match exons distributed throughout a transcript [see @Dalma-Weiszhausz2006, Fig. 4].

To open CEL files of 3' IVT Arrays use the affy package:
Use ReadAffy() to read all CEL files in the folder and load them into an AffyBatch object in R. 
Use the argument celfile.path to specify the location of the folder that contains the CEL files; the `.` symbol specifies that the path to the folder `CEL Files` ends in the current project directory. 

```{r}
raw_data <- ReadAffy(celfile.path = "./CEL Files")
```
Thus, you obtain an AffyBatch object`raw_data` containing the data from all your CEL files. 

## Importing sample information

The `samples_data.csv` file in the project directory contains descritptive features for each sample. 
Specify what kind of data each of its column contains. 

```{r}
sample_data <- read_csv(
  "sample_data.csv", 
  col_types = cols(
    age = col_integer(), 
    day = col_factor(levels = c("1", "2", "3", "4", "5", "6")), 
    generation = col_factor(levels = c("F-1", "F0 + F1", "F2", "F3")), 
    module = col_factor(levels = c("1", "2", "3", "4")), 
    number = col_integer(), 
    replicate = col_factor(levels = c("L3", "L4", "L5", "L7", "L8", "L9", "L10")), 
    sex = col_factor(levels = c("female", "male")), 
    stored = col_date(format = "%m/%d/%Y"), 
    wash = col_factor(levels = c("1", "2", "3", "4")),
    genotype = col_factor(levels = c(
      "test", "control", "w1118", "rpr/cyo; dilp3/ser", "cyo/+; ser/+", "rpr/+; dilp3/+", "cyo/+; dilp3/+", "rpr/+; ser/+"))))
```

## Cleaning the object names

A few of the CEL files have incorrect names. 
This happened because:
1. The registartion process for four of the chips on the AGCC portal did not complete. 
   Therefore, the files for these four chips were named with their serial number (the number stating with the    symbol @).
2. Two chips were registered under the same name by mistake. 
   The file named 2y (created on June 17) is for chip 4y, while the file named real_2y (created on June 24) is    the real 2y.
3. The name of one of the files was not suffixed correctly: it was named 12.1 instead of n12.1
4. Finally, the names of the reminaing files were capitalized inconsistenetly.

The AffyBatch object is just a container holding mutliple matrices and data frames together, each of which is meant to be populated by a different kind of data:
1. A matrix accessed by`exprs()` that is automatically populated with the expression values of the probes when the Affybatch object is created. 
2. An initially empty data frame acceessed by `phenoData()` that is meant to be populated with sample annotation (treatment group, sample number etc.). 
3. An initially empty data frame acceessed by `featureData()` that is meant to be populated with probe annotation (gene names, chromosome location etc.).
The rownames of the `phenoData` have to match the column names of the expression matrix, while the row names of the matrix have to match the row names of the `featureData`. All these names can be accessed  or assigned simultenously by `sampleNames()`.

```{r eval = FALSE}
colnames(exprs(raw_data)) == rownames(phenoData(raw_data))
colnames(exprs(raw_data)) == sampleNames(raw_data)
rownames(phenoData(raw_data)) == sampleNames(raw_data)
```

After checking that the column `sample_data$file_name` will retain the initial file names , we can replace names of the `exprs` and `pData` objects with the `label` column of `sample_data`. 
It contains the corrected and cleaned up (without the string '_(Drosophila_2).CEL') sample names.

```{r}
sampleNames(raw_data) <- sample_data$label
```

Once the names of the AffyBatch sub-part objects have been fixed we will populate the pData object (accessed  using `pData()` but set using `phenoData()`) with the sample information. 
First, the elements of the `label` coulmn have to be converted to rownames of `sample_data`. 
A data frame requires row names before it can be used as an input for `phenoData()`, otherwise `phenoData()` will assign row names by defualt as 1, 2, 3... .

```{r}
rownames(sample_data) <- sample_data$label

# though the command above is deprecated, the newer alternative below won't preserve the `label` column
# sample_data <- sample_data %>% column_to_rownames(var = "label")
```

```{r}
# Optional: remove generations "F-1" and "F0 + F1" 

keep <- pData(raw_data) %>%
  subset(generation != "F-1" &
         generation != "F0 + F1") %>%
  rownames()

esetrownames(pData(raw_data)) <- pData(raw_data)$label #filter() does not preserve rownames, they need to be                                                     reapplied from the `corresponding`label` column

# check that the empty levels were dropped
pData(raw_data) %>%
  select(generation) %>%
  `$`(generation) %>%
  levels()
```

```{r}
# finally, populate phenoData()
phenoData(raw_data) <- AnnotatedDataFrame(sample_data)
```

Finally, we perform multiple checks to ensure that the names were assigned in the proper sequence.

```{r}
#check 1
all(colnames(exprs(raw_data)) == rownames(pData(raw_data)))
#or
all(colnames(exprs(raw_data)) == sampleNames(raw_data))
#or
all(rownames(pData(raw_data)) == sampleNames(raw_data))

#check 2
all(rownames(exprs(raw_data)) %>% head() == rownames(fData(raw_data)) %>% head())

#check 3 (preferred)
validObject(raw_data)
```

edited sample_data.csv to remove "control" from f0+f1 and fixed mislabeling of 4y genotype: it was fixed to "test" from "control"


***

# Quality control of raw data

##Boxplots

##Histograms or density plots

It's necessary to visualize the data before and after each processing step.
To display and contrast the distribution of expression values of multiple arrays on the same plot use `plotDensities()` from the `limma` package. 
Later, this function can be especially helpful to observe the effects of between-array quantile normalization, as mentioned in the package documentation.

```{r eval = FALSE}
raw_expression <- exprs(raw_data) %>% #plotDensities() accepts only matrix/ExpressionSet not AffyBatch objects
                  log2() #the data is log2 scaled to linearize it across different orders of magnitude 

plotDensities(raw_expression, group = pData(raw_data)[, "sex"], legend = "topright",
              main = "Variation in expression according to sex (raw data)")

plotDensities(raw_expression, group = pData(raw_data)[, "day"], legend = "topright",
              main = "Variation in expression according to batch (raw data)")

plotDensities(raw_expression, group = pData(raw_data)[, "genotype"], legend = "topright",
              main = "Variation in expression according to genotype (raw data)")

plotDensities(raw_expression, group = pData(raw_data)[, "replicate"], legend = "topright",
              main = "Variation in expression according to replicate (raw data)")

plotDensities(raw_expression, group = pData(raw_data)[, "generation"], legend = "topright",
              main = "Variation in expression according to generation (raw data)")

#filter and plot only probes with intensities above 6 units:
keep <- rowMeans(raw_expression) > 6
raw_expression2 <- (raw_expression)[keep, ]
plotDensities(raw_expression2, group = pData(raw_data)[, "generation"], legend = "topright",
              main = "Variation in expression according to generation (raw data2)")
```

When data is labeled by sex, no difference is observed between the distirbutions of male and female samples (both males and females show the high-peaked and low-peaked distributions). 
This suggests that their data are comparable and do not need to be analyzed separately within each sex in the subsequent steps.
When the data is labeled by generation, the peaks of the distirbutions of the following two groups are shifted with respect to each other: (a) F-1 & F0 + F1 generations and (b) F2 & F3 generations. 
Further, fewer of the probes from group (a) reach expression intensities above 7 as compared to group (b). 
This contarst between the two groups of distributions becomes apparent if only probes with intensities above 6 units are plotted.
Arrays from all the generations need to be quatile normalized together so that their distributions assume the same shape. 

##MA plots

## The arrayQualityMetrics package
The author's of the package wrote an [Introduction to it](http://bioconductor.org/packages/release/bioc/vignettes/arrayQualityMetrics/inst/doc/arrayQualityMetrics.pdf).
It states the follwoing regrding the use cases for the package.
>  The aim of the `arrayQualityMetrics` package is to produce information that is relevant for your decision making - not, to make the decision. It will often be applied to two,somewhat distinct, use cases: (i) assessing quality of a “raw” dataset, in order toget feedback on the experimental procedures that produced the data; (ii) assessing quality of a normalised dataset, in order to decide whether and how to use the dataset (or subsets of arrays in it) for subsequent data analysis.

As stated in the excerpt, it is used for assesing the quality of the pre-processed arrays below.

```{r eval = FALSE}
require(svglite)
arrayQualityMetrics(expressionset = raw_data[1:4, 1:4], # this can be an AffyBacth object
                    outdir = "Report_for_raw_data", # directory for saving the output file 'index.html'
                    force = TRUE, #overwrite existing files of output directory
                    do.logtransform = TRUE, # log transform the raw ntensities
                    intgroup = "generation" # the name of the covariate(s) used to colour the plots
                    )  
```

##Calculate quality measures in affy 
[Wiki here](https://wiki.bits.vib.be/index.php/Analyze_your_own_microarray_data_in_R/Bioconductor#Calculate_quality_measures_in_affy).

```{r eval = FALSE}
qc(raw_data)
```

# Pre-processing

## Background-correction, summarization, and normalization

In total, three three pre-processing steps need to be performed:
1. Background correction: performed separately for each chip to correct for optical noise and non-specific binding of probes.
2. Quantile normalization: performed on all arrays together to correct for their individual biases, thus make their distributions the same.
3. Summarization: it combines intensity values from all the probes for a single gene into get a single value.

To perform pre-processing steps, use one of the following four functions (their respective packages are indicated before the double column "::"): [1](https://bioconductor.org/packages/release/bioc/manuals/affy/man/affy.pdf), [2](https://support.bioconductor.org/p/18840/#18857) [3](https://bioconductor.org/packages/release/bioc/vignettes/gcrma/inst/doc/gcrma2.0.pdf)
1. `affy::justRMA()` this function reads CEL files & computes expression values without using an AffyBatch object.
2. `affy::expresso()` the arguments for background correction, normalization and summarization for this function have to be set manually.
3. `affy::rma()` this function corrects the background of each chip, performs qunatile-normalization, and summarizes all the probe in a set by robust multi-array (RMA) median polishing.   
It also transforms the expression values to a log2 scale.
4. `gcrma::gcrma()` this function performs background correction by combining the sequence information of each probe (to estimate its non-specific binding) with the information about the noise background of a chip derived by RMA.
The background-corrected probe intensities are quantile-normalized and summarized using the same algorithms as the ones underlying `affy::rma()`. Hence, the initials in its name (GeneChip RMA).


The data were pre-processed separately by `affy::rma()` and `gcrma::gcrma()` and then their respective outputs were plotted for evaluation.



```{r}
eset <- gcrma(raw_data)
eset2 <- rma(raw_data)
```

The ExpressionSet obejects were filtered to remove genes with low expression and then the expression densities were plotted.

```{r eval=FALSE}
eset_list <- list()
eset2_list <- list()

for (i in seq_along (1:15)) {
  keep <- rowMeans(exprs(eset)) > i
  eset_list[[i]] <- eset[keep, ]
  # plotDensities(eset_list[[i]], group = pData(eset_list[[i]])$generation, legend = "topright",
  #                main = str_glue("GCRMA normalized probes with intensities > {i}"))
  }


for (i in seq_along (1:15)) {
  keep <- rowMeans(exprs(eset2)) > i
  eset2_list[[i]] <- eset2[keep, ]
  # plotDensities(eset2_list[i], group = pData(eset2_list[i])$generation, legend = "topright",
  #               main = str_glue("RMA normalized probes with intensities > {i}"))
  }

# convert above `for` loops into map functions
```

`gcrma::gcrma()` generated more normally-shaped distributions than `affy::rma()`.

## Post-proecssing arrayQualityMetrics
To compare the effects of the rma() versus gcrms(), and to decide if any outlier arrays need to be excluded from subsequent analysis, run `arrayQualityMetrics()`. 
The use cases of its package were already discussed in a previous section  [The arrayQualityMetrics package].

```{r eval = FALSE}
require(svglite)
arrayQualityMetrics(expressionset = raw_data[1:4, 1:4], # an ExpressionSet object generated by pre-processing
                    outdir = "Report_for_preprocessed_data", # directory for saving the output file 
                    force = TRUE, #overwrite existing files of output directory
                    do.logtransform = FALSE, # the default value since data is already on log scale
                    intgroup = "generation" # the name of the covariate(s) used to colour the plots
                    )  
```


## Discovering technical variation

To diagnose sources of technical variation, such as batch effects, make an MDS (Multidimensional Scaling) plot of the data. 
MDS abstracts out the largest sources of variation and uses them as automatic axes for a plot. 
The identity of the automatic axes is discovered by checking if they correlate with covariate labels, such as batch number. 

Label the samples according to the following covariates and check if they fall into separate clusters:
1. sex
2. batch (date of processing)
3. genotype
4. generation (F-1, F0 + F1, F2, or F3)
5. replicate (lot for three-generation descent)

```{r eval = FALSE}
plotMDS(eset, labels = pData(eset)[ ,"sex"], gene.selection = "common",
        main = "Variation in expression according to sex (whole data)")

plotMDS(eset, labels = pData(eset)[ ,"day"], gene.selection = "common",
        main = "Variation in expression according to batch (whole data)")

plotMDS(eset, labels = pData(eset)[ ,"genotype"], gene.selection = "common",
        main = "Variation in expression according to genotype (whole data)")

plotMDS(eset, labels = pData(eset)[ ,"generation"], gene.selection = "common",
        main = "Variation in expression according to generation (whole data)")

plotMDS(eset, labels = pData(eset)[ ,"replicate"], gene.selection = "common",
        main = "Variation in expression according to replicate (whole data)")
```

The samples cluster by sex across 'Principal Component 1'.
Therefore, sex is the biggest source of variation in expression.

The samples were subset to remove the variation due to sex and the MDS plots were re-made with the remaining covariates.
 
```{r eval = FALSE}
sample_names_f <- pData(eset) %>% 
                  subset(sex == "female") %>% 
                  rownames()

eset_f <- eset[ , sample_names_f]

plotMDS(eset_f, labels = pData(eset_f)[ ,"generation"], gene.selection = "common",
        main = "Variation in expression according to generation (only female data)")

plotMDS(eset_f, labels = pData(eset_f)[ ,"genotype"], gene.selection = "common",
        main = "Variation in expression according to genotype (only female data)")

plotMDS(eset_f, labels = pData(eset_f)[ ,"day"], gene.selection = "common",
        main = "Variation in expression according to batch (only female data)")

plotMDS(eset_f, labels = pData(eset_f)[ ,"replicate"], gene.selection = "common",
        main = "Variation in expression according to replicate (only female data)")

#####

# sample_names_f2 <- pData(eset) %>% 
#                   subset(sex == "female" & !(replicate == "L9" & generation == "F2")) %>% 
#                   rownames()
# 
# eset_f2 <- eset[ , sample_names_f2]
# 
# plotMDS(eset_f2, labels = pData(eset_f2)[ ,"generation"], gene.selection = "common",
#         main = "Variation in expression according to generation (only female data2)")
# 
# plotMDS(eset_f2, labels = pData(eset_f2)[ ,"genotype"], gene.selection = "common",
#         main = "Variation in expression according to genotype (only female data2)")
# 
# plotMDS(eset_f2, labels = pData(eset_f2)[ ,"day"], gene.selection = "common",
#         main = "Variation in expression according to batch (only female data2)")
# 
#  plotMDS(eset_f2, labels = pData(eset_f2)[ ,"replicate"], gene.selection = "common",
#          main = "Variation in expression according to replicate (only female data2)")
```

The samples fall into two clusters across 'Principal Component 1': cluster (a) consisting of samples from generations F-1 and F0 + F1 or cluster (b) consisting of samples from generations F2 & F3.
To observe clustering across 'Principal Component 2' focus on only the left- or right-half of the plot at a time. 
On observing thus, the samples cluster loosely according to the replicate/batch across. 
The loose clustering becomes clearer if outliers from replicate L9 are removed (plot not shown; corresponding lines of code commented out).


The above pattern repeats with the male samples, the only difference being that 'Principal Component 2' is slightly shorter than observed for females.

```{r eval = FALSE}
sample_names_m <- pData(eset) %>% 
                  subset(sex == "male") %>% 
                  rownames()

eset_m <- eset[ , sample_names_m]

plotMDS(eset_m, labels = pData(eset_m)[ ,"generation"], gene.selection = "common",
        main = "Variation in expression according to generation (only male data)")

plotMDS(eset_m, labels = pData(eset_m)[ ,"genotype"], gene.selection = "common",
        main = "Variation in expression according to genotype (only male data)")

plotMDS(eset_m, labels = pData(eset_m)[ ,"day"], gene.selection = "common",
        main = "Variation in expression according to batch (only male data)")

 plotMDS(eset_m, labels = pData(eset_m)[ ,"replicate"], gene.selection = "common",
         main = "Variation in expression according to replicate (only male data)")
 
 #####
 
#  sample_names_m2 <- pData(eset) %>% 
#                   subset(sex == "male" & !(replicate == "L9" & generation == "F2")) %>% 
#                   rownames()
# 
# eset_m2 <- eset[ , sample_names_m2]
# 
# plotMDS(eset_m2, labels = pData(eset_m2)[ ,"generation"], gene.selection = "common",
#         main = "Variation in expression according to generation (only male data2)")
# 
# plotMDS(eset_m2, labels = pData(eset_m2)[ ,"genotype"], gene.selection = "common",
#         main = "Variation in expression according to genotype (only male data2)")
# 
# plotMDS(eset_m2, labels = pData(eset_m2)[ ,"day"], gene.selection = "common",
#         main = "Variation in expression according to batch (only male data2)")
# 
#  plotMDS(eset_m2, labels = pData(eset_m2)[ ,"replicate"], gene.selection = "common",
#          main = "Variation in expression according to replicate (only male data2)")
```

To prove that the variation between the clusters across 'Principal Component 1' is not biological but technical, subset and plot just the wild-type samples from all the generations, thereby removing the scope for biological variation.

```{r eval = FALSE}
f_wt <- pData(eset) %>% 
        subset(sex == "female" & (genotype == "control" | genotype == "w1118" | genotype == "test")) %>% 
        rownames()

eset_f_wt <- eset[ , f_wt]

plotMDS(eset_f_wt, labels = pData(eset_f_wt)[ ,"generation"], gene.selection = "common",
        main = "Variation in expression according to generation (only female wt data)")

plotMDS(eset_f_wt, labels = pData(eset_f_wt)[ ,"day"], gene.selection = "common",
        main = "Variation in expression according to batch (only female wt data)")

plotMDS(eset_f_wt, labels = pData(eset_f_wt)[ ,"replicate"], gene.selection = "common",
        main = "Variation in expression according to replicate (only female wt data)")

#####

m_wt <- pData(eset) %>%
        subset(sex == "male" & (genotype == "control" | genotype == "w1118" | genotype == "test")) %>%
        rownames()

eset_m_wt <- eset[ , m_wt]

plotMDS(eset_m_wt, labels = pData(eset_m_wt)[ ,"generation"], gene.selection = "common",
        main = "Variation in expression according to generation (only male wt data)")

plotMDS(eset_m_wt, labels = pData(eset_m_wt)[ ,"day"], gene.selection = "common",
        main = "Variation in expression according to batch (only male wt data)")

plotMDS(eset_m_wt, labels = pData(eset_m_wt)[ ,"replicate"], gene.selection = "common",
        main = "Variation in expression according to replicate (only male wt data)")
```

Just the  wild-type samples too fall into two clusters across 'Principal Component 1': cluster (a) consisting of samples from generations F-1 and F0 + F1 or cluster (b) consisting of samples from generations F2 & F3.


# Senstivity analysis of methods dealing with technical variation
Three different methods can deal with technical variation:

**1. Use of the `arrayWeights()` function to apply weights to arrays according to their quality**

Compare `arrayWeights()` and/or `duplicateCorrelation()`, and plain limma.

[Reference on advantage of using the var.design argument within `arrayWeights()`](https://support.bioconductor.org/p/73115/).

[Reference for simultaneously using `duplicateCorrelation()`](https://support.bioconductor.org/p/73527/).

**2. Use of `lme4`, or `limma::duplicateCorrelation()` to treat a technical variable as a random effects variable**

Compare `lme4`, `duplicateCorrelation()`, and plain limma.

The `duplicateCorrelation()` function uses `mixedModel2Fit` from the `statmod` package, which is explcitly a function for building mixed models.

[Refer section 9.7 of limma user guide for usage of the duplicateCorrelation() function](https://bioconductor.org/packages/3.9/bioc/vignettes/limma/inst/doc/usersguide.pdf).

**3. Changing the values within array by using `removeBatchEffect()` or the package `ComBat`**

Compare `removeBatchEffect()`, `ComBat`, and plain limma

[Tutorial on using SVA and ComBat in R](https://www.coursera.org/learn/statistical-genomics/lecture/zsDd4/batch-effects-in-r-part-a-8-18).			

A caveat: for the actual statistical analysis, it is better to include the batch variable as a coefficient when constructing your design matrix. 
Using `removeBatchEffects()` is ideal for exploratory data analysis, especially visualizations.
Accordingly, use it for making the following two plots to check if the signal-to-noise ratio improves:
An MDS plots, of the samples labeled by their batches to check if their effect has been removed.
An MDS plots, of the samples labeled by their treatment to check if its effect has been enhanced.

```{r eval = FALSE}
eset2 <- removeBatchEffect(eset, batch = pData(eset)[, "day"])

plotMDS(eset2, labels = pData(eset)[ ,"sex"], gene.selection = "common",
        main = "Variation in expression according to sex (batch-corrected data)")

plotMDS(eset2, labels = pData(eset)[ ,"day"], gene.selection = "common",
        main = "Variation in expression according to batch (batch-corrected data)")

plotMDS(eset2, labels = pData(eset)[ ,"genotype"], gene.selection = "common",
        main = "Variation in expression according to genotype (batch-corrected data)")

plotMDS(eset2, labels = pData(eset)[ ,"generation"], gene.selection = "common",
        main = "Variation in expression according to generation (batch-corrected data)")

plotMDS(eset2, labels = pData(eset)[ ,"replicate"], gene.selection = "common",
        main = "Variation in expression according to replicate (batch-corrected data)")

```

# Differential expression analysis
## Background

**Selecting the correct statistical test**

The x-axis variable (generation) is categorical, whereas the y-axis variable (the expression of a *single* gene) is continuous . Therefore techniques that require both variables to be continuous like correlation, Pearson's correlation, and Spearman's rank correlation cannot be used. 
Although Spearman's Rho does work with ordinal x-axis variables, the relationship between y and x variables has to be monotonic, which is an assumption that too is probably violated. Thus, only repeated-measures ANOVA or linear regression can be used.

Once a list of DE genes has been generated, a test of proportion can identify if a GO category is over-represented on the list. The test of proportion can with either be one for predictor samples, like Fisher's exact test, or one for repeated-measures, like a GLMM (eg a condtional, repeated-measures logistic regression). An advantage of Fisher's exact test is that it can be applied to sparse data (data where any cell has <5 values) but it does not take the correaltion structure into account. A GLMM does take the correlated structure into account, but it might not be applicable to sparse data. [More on runing models for repeated measures data that isn’t continuous.](https://www.theanalysisfactor.com/models-repeated-measures-continuous-categorical-count-data/)

**Selecting the correct hypotheses**

Assume that there are two independent factors A and B, each with two levels 1 and 2. Two observations would be present at each level of a factor (eg A1B1 & A1B2 for factor A). Then, the following definitions would be applicable:

1. The main effect of a factor is the difference in the means of the two levels of that factor. Thus, 
*main effect of A can be written as `mean(A1B1 + A1B2) - mean(A2B1 + A2B2)` or as `mean(A1) - mean(A2)`
*main effect of B can be written as `mean(B1A1 + B1A2) - mean(B2A1 + B2A2)` or as `mean(B1) - mean(B2)`
*null hypothesis for the main effect of A would be `mean(A1) - mean(A2) = 0` 
*null hypothesis for the main effect of B would be `mean(B1) - mean(B2) = 0` 

2. The simple effect of a factor is the difference in the two levels of that factor at a fixed level of the other factor. Thus,
*simple effect of A at level 1 of B is `A1B1 - A2B1`
*simple effect of A at level 2 of B is `A1B2 - A2B2`
*simple effect of B at level 1 of A is `B1A1 - B2A1`
*simple effect of B at level 2 of A is `B1A2 - B2A2`
*null hypothesis for level 1 effects would be that the simple effects of either factor at level 1 are equal or `mean(A1) - mean(B1) = 0` 
*null hypothesis for level 2 effects would be that the simple effects of either factor at level 2 are equal or `mean(A2) - mean(B2) = 0` 

3. An interaction means that the main effect of a factor changes on moving along the levels of the other factor. Thus,
*[an interaction implies that the simple effects differ](https://www.theanalysisfactor.com/interpreting-interactions-when-the-f-test-and-the-simple-effects-disagree/) so `mean(A1) - mean(B1)` ≠ `mean(A2) - mean(B2)`
*the null hypothesis for the interaction would be `mean(A1) - mean(B1) = mean(A2) - mean(B2)` 

The preceding definitions get translated into the following hypotheses in case of the present study:

1. Is there an interaction between group and time? 
*Visual test: do the lines across the generations diverge for the two groups or are they parallel?
*contrats for statistical test: contrast between the first levels of the two predictor variables is equal to the contrast between the second levels of the two predictor variables is equal to the contrast between the third levels of the two predictor variables.
mean(g2c + g2t) - mean(g2c + g3c) = mean(g3c + g3t) - mean(g2t + g3t)

2. Is there a main effect of generation?
*Visual test: is the slope of the line going from generation F0 to F3 different from zero, after merging control and test groups?
*contrats for statistical test: conduct a one-wy ANOVA after merging the test and control groups, i.e. do any of the generations differ from each other, irrespective of ancestory.

3. Is there a main effect of group?
*Visual test: after averaging across all generations, do averages of the test and control groups differ from each other? 
*contrats for statistical test: average(expression in all generations of test) minus average (expression in all generations of control) is significant for many genes
(F0.test+F1.test+F2.test+F3.test)/4 - (F0.control+F1.control+F2.control+F3.control)/4 is significant for many genes?
Note: an equal number of replicates are not needed for all the generations, even generations with sngle replciates can be included in the contrast above.

**Understanding the results**

* The model coefficient represents the main effect of a predictor variable when an interaction term is n not included in the model. 
* In case an interaction term is included in the model formula, [the model coefficient of a predictor represents its effect at the reference level of the other predictor](https://www.theanalysisfactor.com/interpreting-lower-order-coefficients-when-the-model-contains-an-interaction/), called its conditional effect. Its main effect then is given by its conditional effect plus the interaction effect.
* Although, an insignificant interaction can be dropped from the model, [lower order terms should, whether significant or not, should be retained if the intercation is significant](https://www.theanalysisfactor.com/testing-and-dropping-interaction-terms/).
* The presence of a significant [interaction means that the main effect of a factor is not representative of the simple effects](http://glimo.vub.ac.be/downloads/simpleeffect.htm).
* Simple effects should be tested upon discovering an interaction [to find if a predictor has an effect at each level of the second predictor or at only one of its levels](https://www.theanalysisfactor.com/interpret-main-effects-interaction/).
* It is possible that none of the predictors show a main effect [but an interaction still exists.](https://www.theanalysisfactor.com/interactions-main-effects-not-significant/).
* Use [marginal means to explain the test for interaction to the audience](https://www.theanalysisfactor.com/using-marginal-means-to-explain-an-interaction/]). [Another example](https://www.theanalysisfactor.com/interaction-dummy-variables-in-linear-regression/).
* To visualize the results of the linear regression use `MArrayLM` (?)

> Read Limma user guide from section 9.7 onwards (especially the untility of the `block = ` argument and the single-channel case studies)



## Cleaning up the data

Subset the sex 
```{r}
mini <- pData(eset) %>% 
        subset(
          # sex != "female"
          sex != "male"
               ) %>%
        rownames()

#use the rownames object `mini` to perform the actual subsetting
eset_mini <- eset[ , mini]
```


Clean up and shortern variable names
```{r eval = FALSE}
#retreive remaining rownames after excluding F-1 and three F0 genotypes
mini <- pData(eset) %>% 
        subset(generation != "F-1" & #using filter() instead of subset() does not preserve rownames
                 genotype != "cyo/+; dilp3/+" & 
                 genotype != "rpr/+; ser/+" & 
                 genotype != "rpr/+; dilp3/+" &
                 genotype != "rpr/cyo; dilp3/ser" &
                 # sex      != "female" &
                 sex      != "male"
               ) %>%
        rownames()

#use the rownames object `mini` to perform the actual subsetting
eset_mini <- eset[ , mini]

#convert the `generation` column to a character vector to allow downstream processing
pData(eset_mini)$generation <- pData(eset_mini)$generation %>% as.character()

# #identify the rows that contain the string "dilp3", signifying the F0 generation
# generation_F0 <- pData(eset_mini)$genotype %>%
#   str_which("dilp3")
# 
# #change the `generation` of the rows identified above to "F0"
# pData(eset_mini)[generation_F0, "generation"] <- "F0"

#change the `generation` of the leftover "F0 + F1" genotypes to F1 
pData(eset_mini)$generation <- pData(eset_mini)$generation %>% str_replace("F0 \\+ F1", "F1") 

#convert the `generation` column  back to a factor vecor
pData(eset_mini)$generation <- pData(eset_mini)$generation %>% as.factor()

#convert the `genotype` column to a character vector to allow downstream processing
pData(eset_mini)$genotype <- pData(eset_mini)$genotype %>% as.character()

#replace the `genotype` string `w1118` with the string `control`
pData(eset_mini)$genotype <- pData(eset_mini)$genotype %>% str_replace("w1118", "control")

#replace the other `genotype` strings not matching the string 'control' using the lookahead regex (?!__)
pData(eset_mini)$genotype <- pData(eset_mini)$genotype %>% str_replace("^(?!control)(.*)$", "test")

#convert the `genotype` column  back to a factor vecor
pData(eset_mini)$genotype <- pData(eset_mini)$genotype %>% as.factor()

```

## Model formula 1: Group-means parametrization 
The design formulae for multi-factorial experiments can be written using any type of parametrization:  treatment-contrast, group-means, or sum-to-zero parametrization. According to the `limma` user manual (Section 9.5.4), only the names of the coeffcients in the model objects called `fit` will differ, "all components of [model objects called] `fit2` will be identical regardless of parametrization used".

Build the design matrix using the group-means prametrization. To do so combine all the varaibles of interest, `sex`, `generation` and `genotype`, into a single variable called `group`. The variable `day` holds the replicates and it should automatically get averaged within each `generation`.
```{r}
# Create single variable
group <- with(pData(eset_mini), paste(generation, genotype, sex, sep = "."))
pData(eset_mini)$group <- factor(group)

# Create design matrix with group-means parametrization (no intercept)
design_1 <- model.matrix(~ 0 + group, data = pData(eset_mini))
colnames(design_1) <- levels(pData(eset_mini)$group)
colnames(design_1)

# Count the number of samples modeled by each coefficient
colSums(design_1)

#####
#Build the contrasts matrix for discovering F2:F3 interaction in females by pairing samples within days

contrast_matrix_1 <- makeContrasts(
  # gen_1v0 = (F1.test.female-F0.test.female) - (F1.control.female-F0.control.female),
  # gen_2v1 = (F2.test.female-F1.test.female) - (F2.control.female-F1.control.female),
  gen_3v2 = (
    ((F3.test.female.1-F2.test.female.1) - (F3.control.female.1-F2.control.female.1)) +
    ((F3.test.female.2-F2.test.female.2) - (F3.control.female.2-F2.control.female.2)) +
    ((F3.test.female.3-F2.test.female.3) - (F3.control.female.3-F2.control.female.3))
              )/3,
  # gen_3v1 = (F3.test.female-F1.test.female) - (F3.control.female-F1.control.female),
  levels = design_1)

contrast_matrix_1

#the same contrast matrix is obtained if pairwise differences for the test and control groups are averaged separately and then subtracted from each other, ie above (LHS column)/3 - above (RHS column)/3


#Build the contrasts matrix for females

contrast_matrix_1 <- makeContrasts(
  # gen_1v0 = (F1.test.female-F0.test.female) - (F1.control.female-F0.control.female),
  gen_2v1 = (F2.test.female-F1.test.female) - (F2.control.female-F1.control.female),
  gen_3v2 = (F3.test.female-F2.test.female) - (F3.control.female-F2.control.female),
  gen_3v1 = (F3.test.female-F1.test.female) - (F3.control.female-F1.control.female),
  levels = design_1)

contrast_matrix_1

#Build the contrasts matrix for males

# contrast_matrix_1 <- makeContrasts(
#   # gen_1v0 = (F1.test.male-F0.test.male) - (F1.control.male-F0.control.male),
#   gen_2v1 = (F2.test.male-F1.test.male) - (F2.control.male-F1.control.male),
#   gen_3v2 = (F3.test.male-F2.test.male) - (F3.control.male-F2.control.male),
#   gen_3v1 = (F3.test.male-F1.test.male) - (F3.control.male-F1.control.male),
#   levels = design_1)
# contrast_matrix_1

#####

# #Build the contrasts matrix for discovering main effect of generation in females, wild-type
# 
# cm_1_generation_wt <- makeContrasts(
#   gen_2v1_wt = (F2.control.female - F1.control.female),
#   gen_3v2_wt = (F3.control.female - F2.control.female),
#   gen_3v1_wt = (F3.control.female - F1.control.female),
#   levels = design_1)
# 
# cm_1_generation_wt
# 
# #Build the contrasts matrix for discovering main effect of generation in females, test
# 
# cm_1_generation_tt <- makeContrasts(
#   gen_2v1_tt = (F2.test.female - F1.test.female),
#   gen_3v2_tt = (F3.test.female - F2.test.female),
#   gen_3v1_tt = (F3.test.female - F1.test.female),
#   levels = design_1)
# 
# cm_1_generation_tt

#####

#Test the contrasts/hypotheses

#fit the linear model
fit_model_1 <- lmFit(eset_mini, design_1)

#fit the contrast matrix
fit2_model_1 <- contrasts.fit(fit_model_1, contrast_matrix_1)
fit2_model_1 <- eBayes(fit2_model_1)

#A list of top genes differentially expressed in a contarst can be obtained by specifying its coef
topTable(fit2_model_1, coef=c(1:3), adjust="BH", number = 30)
top_1 <- topTable(fit2_model_1, coef=c(1:3), adjust="BH", number = nrow(fit2_model_1), sort.by = "none")

#Results of all contrasts simultaneously
results_1 <- decideTests(fit2_model_1)
summary(results_1)

#Venn diagram showing numbers of genes significant in all contrasts, simultaneously
vennDiagram(results_1)
```

```{r}
# plot p-value histograms of each ExpressionSet objects containing probes of different intensities 

for(i in seq_along(1:15)){
  
# Create single variable
group <- with(pData(eset2_list[[i]]), paste(generation, genotype, sex, sep = "."))
pData(eset2_list[[i]])$group <- factor(group)

# Create design matrix with group-means parametrization (no intercept)
design_1 <- model.matrix(~ 0 + group, data = pData(eset2_list[[i]]))
colnames(design_1) <- levels(pData(eset2_list[[i]])$group)

#Build the contrasts matrix for females
contrast_matrix_1 <- makeContrasts(
  gen_3v2 = (F3.test.female-F2.test.female) - (F3.control.female-F2.control.female), levels = design_1)

fit_model_1 <- lmFit(eset2_list[[i]], design_1)
fit2_model_1 <- contrasts.fit(fit_model_1, contrast_matrix_1)
fit2_model_1 <- eBayes(fit2_model_1)
top_1 <- topTable(fit2_model_1, adjust="BH", number = nrow(fit2_model_1), sort.by = "none")
hist(top_1$P.Value, breaks = 100, xlim = c(0,1),
      main = str_glue("p-value histogram of probes with intensities above {i} rma"))
}
```

## Model formula 2: nested interaction 
```{r}
design_2 <- model.matrix(~ 0 + genotype:generation, data = pData(eset_mini))
# colnames(design_2) <- c("F1.control.female", "F1.test.female", "F2.control.female", "F2.test.female",
#                        "F3.control.female", "F3.test.female")
colnames(design_2)

# Count the number of samples modeled by each coefficient
#colSums(design_2)

#####

#Build the contrasts matrix

contrast_matrix_2 <- cbind(
gen_2v1 = c(1,-1,-1,1,0,0),
gen_3v2 = c(0,0,1,-1,-1,1),
gen_3v1 = c(1,-1,0,0,-1,1) )

#####

#Test the contrasts/hypotheses

#fit the linear model
fit_model_2 <- lmFit(eset_mini, design_2)

#fit the contrast matrix
fit2_model_2 <- contrasts.fit(fit_model_2, contrast_matrix_2)
fit2_model_2 <- eBayes(fit2_model_2)

#A list of top genes differentially expressed in a contarst can be obtained by specifying its coef
topTable(fit2_model_2, adjust="BH", number = 30)

#Results of all contrasts simultaneously
results_2 <- decideTests(fit2_model_2)
summary(results_2)

#Venn diagram showing numbers of genes significant in all contrasts, simultaneously
vennDiagram(results_2)
```

## Model formula 3: classic interaction 
```{r}
design_3 <- model.matrix(~ 0 + genotype*generation, data = pData(eset_mini))
colnames(design_3)

# Count the number of samples modeled by each coefficient
colSums(design_3)

#####
#Building the contrasts matrix

# contrast_matrix_3 <- cbind(
# gen_2v1 = c(0,0,0,0,1,0),
# gen_3v2 = c(0,0,0,0,-1,1),
# gen_3v1 = c(0,0,0,0,0,1)
# )

#####
#Testing the contrasts/hypotheses

#fit the linear model
fit_model_3 <- lmFit(eset_mini, design_3)

#fit the contrast matrix
# fit2_model_3 <- contrasts.fit(fit_model_3, contrast_matrix_3)
fit2_model_3 <- eBayes(fit_model_3)

#A list of top genes differentially expressed in a contarst can be obtained by specifying its coef
topTable(fit2_model_3, coef = c(5,6), adjust="BH", number = 30)

#Results of all contrasts simultaneously
results_3 <- decideTests(fit2_model_3)
summary(results_3)

#Venn diagram showing numbers of genes significant in the last two coefficients
vennDiagram(object = results_3[ , c(5,6)], names = c("gen_2v1", "gen_3v1"))
```

> gen_3v2 contrast does not appear in method 3, the other two contrasts do appear


>> conclusions based on code below
1. topTable() puts put ANOVA F-values where applicable because its unsorted `P.Val` and `F.p.value` obtained from the `fit2` model objects are the same. 
2. The 29 genes whose adj.P.Val <= 0.05 in topTable are the same as the 28 genes that overlap in the Venn diagram between gen_2v1 and gen_3v1, only probe 1626202_at differs.
3. In boxplots of all these 28 probes (stored in item `sig_F`) only the F1 generation test genotype differs from the other groups; the F1 control and F2 tests and controls cluster together along the Y-axis. It's likely that many other probes also show this pattern, but the F1 test deviation of only these 28 probes is large enough to register as an intercation effect (visual metaphor: the F1 test pulls the test trendline so far away at generation timepoint 1, that the overall test trendline is calculated to be different from the overall control line for these 28 probes.).

>> 
4. Compare a simple model with just the main effect of generation with a complex model including both the main effect and the interaction to see if the interaction is driven completely by the main effect.
5. Perform Tukey pairwise comparison **between** the three contrasts of the interaction to discover which one is significant
6. Similarly perform Tukey pairwise comparison **within** the three contrasts of the main effcet of gneration to discover which one is significant

>>
7. GCRMA the data after removing the first two generations [done]
   remove both, very low **and** very high intensity probes
8. Include more variables in the model
9. check p-val hists of main  effects
10. See if the hups in the density plots correspond to a particular replicates

>>
subsetting with square brackets returns a data frame and subsetting with $ returns a vector

>>
Search Datacamp courses (listed in Google Keep) to make ggplot versions of the plots.

```{r}
venn_overlap <- results_1@.Data %>% subset(results_1@.Data[ , "gen_2v1"] != 0 & 
                     results_1@.Data[ , "gen_3v1"] != 0) %>% 
                      rownames()

sig_F <- top_1 %>% subset(adj.P.Val <= 0.05) %>% rownames()

venn_overlap 
sig_F 

#boxplot of all the groups pf gene i in the list sig_F
boxplot(exprs(eset_mini)[sig_F[i], ] ~ pData(eset_mini)[ , "group"])

ggplot(data = pData(eset_mini), aes(x = generation, exprs(eset_mini)[sig_F[29], ], fill=genotype)) +
  # geom_point(aes(col = genotype), position = position_jitter(0.1), shape = 1, size = 5) +
  geom_dotplot(position = position_jitter(0.1), binaxis = "y", stackdir = "center", alpha = 0.7) +
  theme_classic()
```


# Acknowledgements
(Incorporate these acknowledgements into the references)
This content was developed by heavily modifying content from [VIB Bioinformatics Core Wiki](https://wiki.bits.vib.be/index.php/Analyze_your_own_microarray_data_in_R/Bioconductor) and [@Klaus2019]

(Correct the terminology for the variables. Check out https://www.theanalysisfactor.com/whats-in-a-name-moderation-and-interaction-predictor-and-predictor-variables/)

***

# References


