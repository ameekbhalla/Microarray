---
title: "Microarray Pipeline"
author: "Ameek Bhalla"
editor_options:
  chunk_output_type: console
output:
  html_notebook:
    number_sections: yes
    theme: readable
    toc: yes
    toc_depth: '2'
    toc_float: yes
  html_document:
    df_print: paged
    number_sections: yes
    theme: readable
    toc: yes
    toc_depth: '2'
    toc_float: yes
bibliography: Microarray references.bib
---

***

# Useful commands

* Insert a link: `[R Markdown](http://rmarkdown.rstudio.com)`
* Insert a new chunk: `Ctrl+Alt+I`
* Execute a code chunk: `Ctrl+Shift+Enter`
* Preview the html file: `Ctrl+Shift+K`
* Install Bioconductor
+ quietly check if Bioconductor is already installed
   `if(!requireNamespace("BiocManager", quietly = TRUE))`
+ install Bioconductor if not in Namespace:
    `install.packages("BiocManager")` 
* Install a Bioconductor package:`BiocManager::install("package.name")`

# Setup

## Set default chunk options

The default chunk options can be set in the first chunk itself. Later, the behaviour of individuals chunks can be modified by modifying a specific argument.

```{r}
knitr::opts_chunk$set(results = "hide", 
                      tidy = TRUE)
```

## Load Packages

```{r results = "hide"}
library(affy) # Bioconductor package for analysis of older Affymetrix arrays
#library(affyio)
#library(affyPLM)
#library(annaffy)
#library(annotate)
#library(arrayQualityMetrics)
library(BiocManager)
library(drosophila2.db) # annotation package for the model organism
library(drosophila2cdf)
library(formatR)
library(gcrma)
library(htmltools)
library(knitr)
library(limma)
#library(markdown)
library(rmarkdown)
#library(simpleaffy)
library(tidyverse)
```

# Importing data into R

## Importing CEL files into R

In 3' IVT arrays, the probe set matches the 600bp region adjacent to the 3' end of a transcript. 
This is because 3' IVT assays use oligo-dT primers during the cDNA step. 
This causes preferntial amplification of the 3' region adjacent to poly(A) tail of the mRNA. 
3' IVT assays are most commonly used for whole-genome transcriptome experiments. In the newer, exon arrays, the probe sets match exons distributed throughout a transcript [see @Dalma-Weiszhausz2006, Fig. 4].

To open CEL files of 3' IVT Arrays use the `affy` package. Its `ReadAffy()` function reads all the .CEL files present in the folder and loads them into an AffyBatch object in R. 
Use the argument celfile.path to specify the location of the folder that contains the CEL files; the `.` symbol specifies that the path to the folder `CEL Files` ends in the current project directory. 

```{r}
raw_data <- ReadAffy(celfile.path = "./CEL Files")
```
Thus, you obtain an AffyBatch object`raw_data` containing the data from all your CEL files. 
However, the AffyBatch object is just a container holding mutliple matrices and data frames together. Each of thee is meant to be populated by a different kind of data:
1. A matrix accessed by`exprs()` that is automatically populated with the expression values of the probes when the Affybatch object is created. 
2. An initially empty data frame acceessed by `phenoData()` that is meant to be populated with sample annotation (treatment group, sample number etc.). 
3. An initially empty data frame acceessed by `featureData()` that is meant to be populated with probe annotation (gene names, chromosome location etc.).

The row names of the `phenoData` must match the column names of the expression matrix, while the row names of the expression matrix much match the row names of the `featureData`. All these names can be accessed simultenously using `sampleNames()`.

## Importing sample information

The `samples_data.csv` file in the project directory contains descritptive features for each sample. Import the file into an obeject called `sample_data` and specify what kind of data each of its column contains. 

```{r}
sample_data <- read_csv(
  "sample_data.csv", 
  col_types = cols(
    age = col_integer(), 
    day = col_factor(levels = c("1", "2", "3", "4", "5", "6")), 
    generation = col_factor(levels = c("F-1", "F0 + F1", "F2", "F3")), 
    module = col_factor(levels = c("1", "2", "3", "4")), 
    number = col_integer(), 
    replicate = col_factor(levels = c("L3", "L4", "L5", "L7", "L8", "L9", "L10")), 
    sex = col_factor(levels = c("female", "male")), 
    stored = col_date(format = "%m/%d/%Y"), 
    wash = col_factor(levels = c("1", "2", "3", "4")),
    genotype = col_factor(levels = c(
      "control",  "test", "w1118", "rpr/cyo; dilp3/ser", "cyo/+; ser/+", "rpr/+; dilp3/+", "cyo/+; dilp3/+", "rpr/+; ser/+"))))
```

Use `sample_data` to populate the `phenoData` data frame inside the Affybatch object (accessed using `pData()` but set using `phenoData()`). 

```{r}
phenoData(raw_data) <- AnnotatedDataFrame(sample_data)
```

## Cleaning the sample names

The `ReadAffy()` function uses the full names of the files it imports (including the string '_(Drosophila_2).CEL') as the default input for `sampleNames()`. However, a few of the .CEL files had erroneous names:
1. The registartion process for four of the chips on the AGCC portal did not complete. 
Therefore, the files for these four chips were named with their serial number (the number stating with the symbol @).
2. Two chips were registered under the same name by mistake. 
The file named 2y (created on June 17) is for chip 4y, while the file named real_2y (created on June 24) is    the real 2y.
3. The name of one of the files was not suffixed correctly: it was named 12.1 instead of n12.1
4. Finally, the names of the reminaing files were capitalized inconsistenetly.

The corrected and cleaned up sample names (without the string '_(Drosophila_2).CEL') are present in the `label` column of the file `samples_data.csv` imported earlier. Use `sampleNames()` to access and replace the default sample names. 

```{r}
sampleNames(raw_data) <- sample_data$label
```

Finally, we perform multiple checks to ensure that the names were assigned in the proper sequence. As sateted already, for an Affybatch object to be valid, the row names of its `phenoData` must match the column names of its expression matrix, while the row names of the expression matrix much match the row names of its `featureData`.

```{r}

all(colnames(exprs(raw_data)) == rownames(pData(raw_data)))

all(colnames(exprs(raw_data)) == sampleNames(raw_data))

all(rownames(pData(raw_data)) == sampleNames(raw_data))

all(rownames(exprs(raw_data)) %>% head() == rownames(fData(raw_data)) %>% head())

# one-line check
validObject(raw_data)
```

# Quality control of raw data

## Histograms or density plots

It's necessary to visualize the data before and after each processing step.
To display and contrast the distribution of expression values of multiple arrays on the same plot use `plotDensities()` from the `limma` package. 
Later, this function can be especially helpful to observe the effects of between-array quantile normalization, as mentioned in the package documentation.

```{r eval = FALSE}
raw_expression <- exprs(raw_data) %>% #plotDensities() accepts only matrix/ExpressionSet objects
                  log2() #the data is log2 scaled to linearize it across different orders of magnitude 

plotDensities(raw_expression, group = pData(raw_data)$sex, legend = "topright",
              main = "Variation in expression according to sex (raw data)")

plotDensities(raw_expression, group = pData(raw_data)$day, legend = "topright",
              main = "Variation in expression according to batch (raw data)")

plotDensities(raw_expression, group = pData(raw_data)$genotype, legend = "topright",
              main = "Variation in expression according to genotype (raw data)")

plotDensities(raw_expression, group = pData(raw_data)$replicate, legend = "topright",
              main = "Variation in expression according to replicate (raw data)")

plotDensities(raw_expression, group = pData(raw_data)$generation, legend = "topright",
              main = "Variation in expression according to generation (raw data)")

#filter and plot only probes with intensities above 6 units:
keep <- rowMeans(raw_expression) > 6
raw_expression2 <- (raw_expression)[keep, ]
plotDensities(raw_expression2, group = pData(raw_data)$generation, legend = "topright",
              main = "Variation in expression according to generation (raw data2)")
```

When data is labeled by sex, no difference is observed between the distirbutions of male and female samples (both males and females show the high-peaked and low-peaked distributions). 
This suggests that their data are comparable and do not need to be analyzed separately within each sex in the subsequent steps.
When the data is labeled by generation, the peaks of the distirbutions of the following two groups are shifted with respect to each other: (a) F-1 & F0 + F1 generations and (b) F2 & F3 generations. 
Further, fewer of the probes from group (a) reach expression intensities above 7 as compared to group (b). 
This contarst between the two groups of distributions becomes apparent if only probes with intensities above 6 units are plotted.
Therefore, arrays from all the generations need to be quatile normalized together during pre-processing so that their distributions assume the same shape. 

## The arrayQualityMetrics package
The author's of the package wrote an [Introduction to it](http://bioconductor.org/packages/release/bioc/vignettes/arrayQualityMetrics/inst/doc/arrayQualityMetrics.pdf).
It states the follwoing regrding the use cases for the package.
>  The aim of the `arrayQualityMetrics` package is to produce information that is relevant for your decision making - not, to make the decision. It will often be applied to two,somewhat distinct, use cases: (i) assessing quality of a “raw” dataset, in order toget feedback on the experimental procedures that produced the data; (ii) assessing quality of a normalised dataset, in order to decide whether and how to use the dataset (or subsets of arrays in it) for subsequent data analysis.

As stated in the excerpt, it is used for assesing the quality of the pre-processed arrays below.

```{r eval = FALSE}
require(svglite)
arrayQualityMetrics(expressionset = raw_data[1:4, 1:4], # this can be an AffyBacth object
                    outdir = "Report_for_raw_data", # directory for saving the output file 'index.html'
                    force = TRUE, #overwrite existing files of output directory
                    do.logtransform = TRUE, # log transform the raw ntensities
                    intgroup = "generation" # the name of the covariate(s) used to colour the plots
                    )  
```

## Calculate quality measures in affy 
[Wiki here](https://wiki.bits.vib.be/index.php/Analyze_your_own_microarray_data_in_R/Bioconductor#Calculate_quality_measures_in_affy).

```{r eval = FALSE}
qc(raw_data)
```

## Boxplots

## MA plots

# Pre-processing

## Background-correction, summarization, and normalization

In total, three three pre-processing steps need to be performed:
1. Background correction: performed separately for each chip to correct for optical noise and non-specific binding of probes.
2. Quantile normalization: performed on all arrays together to correct for their individual biases, thus make their distributions the same.
3. Summarization: it combines intensity values from all the probes for a single gene into get a single value.

To perform pre-processing steps, use one of the following four functions (their respective packages are indicated before the double column "::"): [1](https://bioconductor.org/packages/release/bioc/manuals/affy/man/affy.pdf), [2](https://support.bioconductor.org/p/18840/#18857) [3](https://bioconductor.org/packages/release/bioc/vignettes/gcrma/inst/doc/gcrma2.0.pdf)
1. `affy::justRMA()` this function reads CEL files & computes expression values without using an AffyBatch object.
2. `affy::expresso()` the arguments for background correction, normalization and summarization for this function have to be set manually.
3. `affy::rma()` this function corrects the background of each chip, performs qunatile-normalization, and summarizes all the probe in a set by robust multi-array (RMA) median polishing.   
It also transforms the expression values to a log2 scale.
4. `gcrma::gcrma()` this function performs background correction by combining the sequence information of each probe (to estimate its non-specific binding) with the information about the noise background of a chip derived by RMA.
The background-corrected probe intensities are quantile-normalized and summarized using the same algorithms as the ones underlying `affy::rma()`. Hence, the initials in its name (GeneChip RMA).


The data were pre-processed separately by `affy::rma()` and `gcrma::gcrma()` and then their respective outputs were plotted for evaluation.

```{r eval = FALSE}
# Optional: remove generations "F-1" and "F0 + F1" before pre-processing
keep <- which(pData(raw_data)$generation != "F-1" & pData(raw_data)$generation != "F0 + F1")

raw_data <- raw_data[ , keep] #ExpressionSet objects cannot be subset with filter() or filter()  

# drop empty levels
pData(raw_data)$generation <- pData(raw_data)$generation %>% droplevels()

# subsetting an AffyBatch object removes row names so they need be reassigned
sampleNames(raw_data) <- pData(raw_data)$label
```

```{r}
eset <- gcrma(raw_data)
#eset2 <- rma(raw_data)
```

The ExpressionSet obejects were filtered to remove genes with low expression and then the expression densities were plotted.

```{r eval=FALSE}
eset_list <- list()
eset2_list <- list()

for (i in seq_along (1:15)) {
  keep <- rowMeans(exprs(eset)) > i
  eset_list[[i]] <- eset[keep, ] #ExpressionSet objects cannot be subset with filter() or filter()
  plotDensities(eset_list[[i]], group = pData(eset_list[[i]])$generation, legend = "topright",
                 main = str_glue("GCRMA normalized probes with intensities > {i}"))
  }


for (i in seq_along (1:15)) {
  keep <- rowMeans(exprs(eset2)) > i
  eset2_list[[i]] <- eset2[keep, ] #ExpressionSet objects cannot be subset with filter() or filter()
  plotDensities(eset2_list[[i]], group = pData(eset2_list[[i]])$generation, legend = "topright",
                main = str_glue("RMA normalized probes with intensities > {i}"))
  }

# convert above `for` loops into map functions
```

`gcrma::gcrma()` generated more normally-shaped distributions than `affy::rma()`.

## Post-proecssing arrayQualityMetrics
To compare the effects of the rma() versus gcrma(), and to decide if any outlier arrays need to be excluded from subsequent analysis, run `arrayQualityMetrics()`. 
The use cases of its package were already discussed in a previous section  [The arrayQualityMetrics package].

```{r eval = FALSE}
require(svglite)
arrayQualityMetrics(expressionset = raw_data[1:4, 1:4], # an ExpressionSet object generated by pre-processing
                    outdir = "Report_for_preprocessed_data", # directory for saving the output file 
                    force = TRUE, #overwrite existing files of output directory
                    do.logtransform = FALSE, # the default value since data is already on log scale
                    intgroup = "generation" # the name of the covariate(s) used to colour the plots
                    )  
```


## Discovering technical variation

To diagnose sources of technical variation, such as batch effects, make an MDS (Multidimensional Scaling) plot of the data. 
MDS abstracts out the largest sources of variation and uses them as automatic axes for a plot. 
The identity of the automatic axes is discovered by checking if they correlate with covariate labels, such as batch number. 

Label the samples according to the following covariates and check if they fall into separate clusters:
1. sex
2. batch (date of processing)
3. genotype
4. generation (F-1, F0 + F1, F2, or F3)
5. replicate (lot for three-generation descent)

```{r eval = FALSE}
plotMDS(eset, labels = pData(eset)$sex, gene.selection = "common",
        main = "Variation in expression according to sex (whole data)")

plotMDS(eset, labels = pData(eset)$day, gene.selection = "common",
        main = "Variation in expression according to batch (whole data)")

plotMDS(eset, labels = pData(eset)$genotype, gene.selection = "common",
        main = "Variation in expression according to genotype (whole data)")

plotMDS(eset, labels = pData(eset)$generation, gene.selection = "common",
        main = "Variation in expression according to generation (whole data)")

plotMDS(eset, labels = pData(eset)$replicate, gene.selection = "common",
        main = "Variation in expression according to replicate (whole data)")
```

The samples cluster by sex across 'Principal Component 1'.
Therefore, sex is the biggest source of variation in expression.

The samples were subset to remove the variation due to sex and the MDS plots were re-made with the remaining covariates.
 
```{r eval = FALSE}
sample_names_f <- which(pData(eset)$sex == "female")

eset_f <- eset[ , sample_names_f] #ExpressionSet objects cannot be subset with filter() or filter()

plotMDS(eset_f, labels = pData(eset_f)$generation, gene.selection = "common",
        main = "Variation in expression according to generation (only female data)")

plotMDS(eset_f, labels = pData(eset_f)$genotype, gene.selection = "common",
        main = "Variation in expression according to genotype (only female data)")

plotMDS(eset_f, labels = pData(eset_f)$day, gene.selection = "common",
        main = "Variation in expression according to batch (only female data)")

plotMDS(eset_f, labels = pData(eset_f)$replicate, gene.selection = "common",
        main = "Variation in expression according to replicate (only female data)")

#####
# keep_not <-  which(pData(eset_f)$replicate == "L9" & pData(eset_f)$generation == "F2")
# 
# eset_f2 <- eset_f[ , -keep_not] #ExpressionSet objects cannot be subset with filter() or filter()
# 
# plotMDS(eset_f2, labels = pData(eset_f2)$generation, gene.selection = "common",
#         main = "Variation in expression according to generation (only female data2)")
# 
# plotMDS(eset_f2, labels = pData(eset_f2)$genotype, gene.selection = "common",
#         main = "Variation in expression according to genotype (only female data2)")
# 
# plotMDS(eset_f2, labels = pData(eset_f2)$day, gene.selection = "common",
#         main = "Variation in expression according to batch (only female data2)")
# 
#  plotMDS(eset_f2, labels = pData(eset_f2)$replicate, gene.selection = "common",
#          main = "Variation in expression according to replicate (only female data2)")
```

The samples fall into two clusters across 'Principal Component 1': cluster (a) consisting of samples from generations F-1 and F0 + F1 or cluster (b) consisting of samples from generations F2 & F3.
To observe clustering across 'Principal Component 2' focus on only the left- or right-half of the plot at a time. 
On observing thus, the samples cluster loosely according to the replicate/batch across. 
The loose clustering becomes clearer if outliers from replicate L9 are removed (plot not shown; corresponding lines of code commented out).


The above pattern repeats with the male samples, the only difference being that 'Principal Component 2' is slightly shorter than observed for females.

```{r eval = FALSE}
sample_names_m <- which(pData(eset)$sex == "male")

eset_m <- eset[ , sample_names_m] #ExpressionSet objects cannot be subset with filter() or filter()

plotMDS(eset_m, labels = pData(eset_m)$generation, gene.selection = "common",
        main = "Variation in expression according to generation (only male data)")

plotMDS(eset_m, labels = pData(eset_m)$genotype, gene.selection = "common",
        main = "Variation in expression according to genotype (only male data)")

plotMDS(eset_m, labels = pData(eset_m)$day, gene.selection = "common",
        main = "Variation in expression according to batch (only male data)")

 plotMDS(eset_m, labels = pData(eset_m)$replicate, gene.selection = "common",
         main = "Variation in expression according to replicate (only male data)")
 
 #####
 
#  keep_not <- which(
#                           pData(eset_m)$replicate == "L9" & 
#                           pData(eset_m)$generation == "F2"
#                           )
# 
# eset_m2 <- eset_m[ , -keep_not] #ExpressionSet objects cannot be subset with subset()/filter()
# 
# plotMDS(eset_m2, labels = pData(eset_m2)$generation, gene.selection = "common",
#         main = "Variation in expression according to generation (only male data2)")
# 
# plotMDS(eset_m2, labels = pData(eset_m2)$genotype, gene.selection = "common",
#         main = "Variation in expression according to genotype (only male data2)")
# 
# plotMDS(eset_m2, labels = pData(eset_m2)$day, gene.selection = "common",
#         main = "Variation in expression according to batch (only male data2)")
#
#  plotMDS(eset_m2, labels = pData(eset_m2)$replicate, gene.selection = "common",
#          main = "Variation in expression according to replicate (only male data2)")
```

To prove that the variation between the clusters across 'Principal Component 1' is not biological but technical, subset and plot just the wild-type samples from all the generations, thereby removing the scope for biological variation.

```{r eval = FALSE}
f_wt <- which(pData(eset)$sex      == "female"& ( 
              pData(eset)$genotype == "control" | 
              pData(eset)$genotype == "w1118"   | 
              pData(eset)$genotype == "test"    )
              )
eset_f_wt <- eset[ , f_wt] #ExpressionSet objects cannot be subset with filter() or filter()

plotMDS(eset_f_wt, labels = pData(eset_f_wt)$generation, gene.selection = "common",
        main = "Variation in expression according to generation (only female wt data)")

plotMDS(eset_f_wt, labels = pData(eset_f_wt)$day, gene.selection = "common",
        main = "Variation in expression according to batch (only female wt data)")

plotMDS(eset_f_wt, labels = pData(eset_f_wt)$replicate, gene.selection = "common",
        main = "Variation in expression according to replicate (only female wt data)")

#####

m_wt <- which(pData(eset)$sex      == "male"&   (
              pData(eset)$genotype == "control" | 
              pData(eset)$genotype == "w1118"   | 
              pData(eset)$genotype == "test"    )
              )

eset_m_wt <- eset[ , m_wt] #ExpressionSet objects cannot be subset with filter() or filter()

plotMDS(eset_m_wt, labels = pData(eset_m_wt)$generation, gene.selection = "common",
        main = "Variation in expression according to generation (only male wt data)")

plotMDS(eset_m_wt, labels = pData(eset_m_wt)$day, gene.selection = "common",
        main = "Variation in expression according to batch (only male wt data)")

plotMDS(eset_m_wt, labels = pData(eset_m_wt)$replicate, gene.selection = "common",
        main = "Variation in expression according to replicate (only male wt data)")
```

Just the  wild-type samples too fall into two clusters across 'Principal Component 1': cluster (a) consisting of samples from generations F-1 and F0 + F1 or cluster (b) consisting of samples from generations F2 & F3.


# Senstivity analysis of methods dealing with technical variation
Three different methods can deal with technical variation:

**1. Use of the `arrayWeights()` function to apply weights to arrays according to their quality**

Compare `arrayWeights()` and/or `duplicateCorrelation()`, and plain limma.

[Reference on advantage of using the var.design argument within `arrayWeights()`](https://support.bioconductor.org/p/73115/).

[Reference for simultaneously using `duplicateCorrelation()`](https://support.bioconductor.org/p/73527/).

**2. Use of `lme4`, or `limma::duplicateCorrelation()` to treat a technical variable as a random effects variable**

Compare `lme4`, `duplicateCorrelation()`, and plain limma.

The `duplicateCorrelation()` function uses `mixedModel2Fit` from the `statmod` package, which is explcitly a function for building mixed models.

[Refer section 9.7 of limma user guide for usage of the duplicateCorrelation() function](https://bioconductor.org/packages/3.9/bioc/vignettes/limma/inst/doc/usersguide.pdf).

**3. Changing the values within array by using `removeBatchEffect()` or the package `ComBat`**

Compare `removeBatchEffect()`, `ComBat`, and plain limma

[Tutorial on using SVA and ComBat in R](https://www.coursera.org/learn/statistical-genomics/lecture/zsDd4/batch-effects-in-r-part-a-8-18).			

A caveat: for the actual statistical analysis, it is better to include the batch variable as a coefficient when constructing your design matrix. 
Using `removeBatchEffects()` is ideal for exploratory data analysis, especially visualizations.
Accordingly, use it for making the following two plots to check if the signal-to-noise ratio improves:
An MDS plots, of the samples labeled by their batches to check if their effect has been removed.
An MDS plots, of the samples labeled by their treatment to check if its effect has been enhanced.

```{r eval = FALSE}
eset2 <- removeBatchEffect(eset, batch = pData(eset)$day)

plotMDS(eset2, labels = pData(eset)$sex, gene.selection = "common",
        main = "Variation in expression according to sex (batch-corrected data)")

plotMDS(eset2, labels = pData(eset)$day, gene.selection = "common",
        main = "Variation in expression according to batch (batch-corrected data)")

plotMDS(eset2, labels = pData(eset)$genotype, gene.selection = "common",
        main = "Variation in expression according to genotype (batch-corrected data)")

plotMDS(eset2, labels = pData(eset)$generation, gene.selection = "common",
        main = "Variation in expression according to generation (batch-corrected data)")

plotMDS(eset2, labels = pData(eset)$replicate, gene.selection = "common",
        main = "Variation in expression according to replicate (batch-corrected data)")

```

# Background

**Selecting the correct statistical test**

The x-axis variable (generation) is categorical, whereas the y-axis variable (the expression of a *single* gene) is continuous . Therefore techniques that require both variables to be continuous like correlation, Pearson's correlation, and Spearman's rank correlation cannot be used. 
Although Spearman's Rho does work with ordinal x-axis variables, the relationship between y and x variables has to be monotonic, which is an assumption that too is probably violated. Thus, only repeated-measures ANOVA or linear regression can be used.

Once a list of DE genes has been generated, a test of proportion can identify if a GO category is over-represented on the list. The test of proportion can either be one based on a single predictor, like Fisher's exact test, or one based on multiple predictors, like GLMMs (eg a condtional, repeated-measures logistic regression). An advantage of Fisher's exact test is that it can be applied to sparse data (data where any cell has <5 values) but it does not take the correaltion structure into account. A GLMM does take the correlated structure into account, but it might not be applicable to sparse data. [More on runing models for repeated measures data that isn’t continuous.](https://www.theanalysisfactor.com/models-repeated-measures-continuous-categorical-count-data/)

#### 
**Defining all the hypotheses**
Ignore this sub-section, if you are already familiar with the definitions of main effects, simple effects, and interactions

Assume that there are two independent factors A and B, each with two levels 1 and 2. Two observations would be present at each level of a factor (eg A1B1 & A1B2 for factor A). Then, the following definitions would be applicable:

1. The main effect of a factor is the difference in the means of the two levels of that factor. Thus, 
*main effect of A can be written as `mean(A1B1 + A1B2) - mean(A2B1 + A2B2)` or as `mean(A1) - mean(A2)`
*main effect of B can be written as `mean(B1A1 + B1A2) - mean(B2A1 + B2A2)` or as `mean(B1) - mean(B2)`
*null hypothesis for the main effect of A would be `mean(A1) - mean(A2) = 0` 
*null hypothesis for the main effect of B would be `mean(B1) - mean(B2) = 0` 

2. The simple effect of a factor is the difference in the two levels of that factor at a fixed level of the other factor. Thus,
*simple effect of A at level 1 of B is `A1B1 - A2B1`
*simple effect of A at level 2 of B is `A1B2 - A2B2`
*simple effect of B at level 1 of A is `B1A1 - B2A1`
*simple effect of B at level 2 of A is `B1A2 - B2A2`
*null hypothesis for level 1 effects would be that the simple effects of either factor at level 1 are equal or `mean(A1) - mean(B1) = 0` 
*null hypothesis for level 2 effects would be that the simple effects of either factor at level 2 are equal or `mean(A2) - mean(B2) = 0` 

3. An interaction means that the main effect of a factor changes on moving along the levels of the other factor. Thus,
*[an interaction implies that the simple effects differ](https://www.theanalysisfactor.com/interpreting-interactions-when-the-f-test-and-the-simple-effects-disagree/) so `mean(A1) - mean(B1)` ≠ `mean(A2) - mean(B2)`
*the null hypothesis for the interaction would be `mean(A1) - mean(B1) = mean(A2) - mean(B2)` 
####

**Formulating the hypotheses for the present study**
The preceding definitions get translated into the following hypotheses in case of the present study:

1. Is there an interaction between genotype and generation? 
*Visual test: do the lines across the generations diverge for the two genotypes or are they parallel?
*contrats for statistical test: difference between the two genotypes at generation 1 is equal to the difference between the two genotypes at generation 2 is equal to the difference between the two genotypes at generation 3. Equivalently, simple effect of generation (calculated from either gener1-gener2 or gener2-gener3) differs for the two genotypes.
~~mean(g2c + g2t) - mean(g2c + g3c) = mean(g3c + g3t) - mean(g2t + g3t)~~
Update: g1t-g1c = g2t-g2c; g2t-g2c = g3t-g3c. Equivalently g3t-g2t = g3c-g2c; g2t-g1t = g2c-g1c

2. Is there a main effect of generation?
*Visual test: is the slope of the line connecting any two consecutive generations different from zero, after merging control and test groups?
*contrats for statistical test: (g1t+g1c)/2 = (g2t+g2c)/2 = (g3t+g3c)/2

3. Is there a main effect of group?
*Visual test: do the test and control genotype lines differ from each other? 
*contrats for statistical test: average(expression in all generations of test) minus average (expression in all generations of control) is significant for many genes
(F0.test+F1.test+F2.test+F3.test)/4 - (F0.control+F1.control+F2.control+F3.control)/4 is significant for many genes?
Note: an equal number of replicates are not needed for all the generations, even generations with single replciates can be included in the contrast above.

**Understanding the results**

* The model coefficient represents the main effect of a predictor variable when an interaction term is not included in the model. 
* In case an interaction term is included in the model formula, [the model coefficient of a predictor represents its effect at the reference level of the other predictor](https://www.theanalysisfactor.com/interpreting-lower-order-coefficients-when-the-model-contains-an-interaction/), called its simple/conditional effect. Its main effect then is given by its conditional effect plus the interaction effect.
* Although, an insignificant interaction can be dropped from the model, [lower order terms should, whether significant or not, be retained if the intercation is significant](https://www.theanalysisfactor.com/testing-and-dropping-interaction-terms/).
* The presence of a significant [interaction means that the main effect of a factor is not representative of the simple effects](http://glimo.vub.ac.be/downloads/simpleeffect.htm).
* Simple effects should be tested upon discovering an interaction [to find if a predictor has an effect at each level of the second predictor or at only one of its levels](https://www.theanalysisfactor.com/interpret-main-effects-interaction/).
* It is possible that none of the predictors show a main effect [but an interaction still exists.](https://www.theanalysisfactor.com/interactions-main-effects-not-significant/).
* Use [marginal means to explain the test for interaction to the audience](https://www.theanalysisfactor.com/using-marginal-means-to-explain-an-interaction/]). [Second example](https://www.theanalysisfactor.com/interaction-dummy-variables-in-linear-regression/).
* To visualize the results of the linear regression use `MArrayLM` (?)

# Differential expression analysis
## Cleaning up the data
Subset the data and clean up the names of the factor levels
```{r genotype_cleanup}
#retreive remaining rownames after excluding F-1, three F0 genotypes, and males
mini <-  which(
  pData(eset)$generation != "F-1" & #using filter() instead of subset() does not preserve rownames
  # pData(eset)$generation != "F0 + F1" &
  pData(eset)$genotype   != "cyo/+; dilp3/+" & 
  pData(eset)$genotype   != "rpr/+; ser/+" & 
  pData(eset)$genotype   != "rpr/+; dilp3/+" &
  pData(eset)$genotype   != "rpr/cyo; dilp3/ser" &
  # pData(eset)$sex        != "female" &
  pData(eset)$sex        != "male"
                )
#use the rownames object `mini` to perform the actual subsetting
eset_mini <- eset[ , mini] #ExpressionSet objects cannot be subset with filter() or subset()
remove(mini)

pData(eset_mini)$sex <- pData(eset_mini)$sex %>% droplevels()
pData(eset_mini)$generation <- pData(eset_mini)$generation %>% droplevels()
pData(eset_mini)$genotype <- pData(eset_mini)$genotype %>% droplevels()
pData(eset_mini)$day <- pData(eset_mini)$day %>% droplevels()


#convert the `generation` column to a character vector to allow downstream processing
pData(eset_mini)$generation <- pData(eset_mini)$generation %>% as.character()

# #identify the rows that contain the string "dilp3", signifying the F0 generation
# generation_F0 <- pData(eset_mini)$genotype %>%
#   str_which("dilp3")
#
# #change the `generation` of the rows identified above to "F0"
# pData(eset_mini)[generation_F0, "generation"] <- "F0"

#change the `generation` of the leftover "F0 + F1" genotypes to F1
pData(eset_mini)$generation <- pData(eset_mini)$generation %>% str_replace("F0 \\+ F1", "F1")

#convert the `generation` column  back to a factor vecor
pData(eset_mini)$generation <- pData(eset_mini)$generation %>% as.factor()

#convert the `genotype` column to a character vector to allow downstream processing
pData(eset_mini)$genotype <- pData(eset_mini)$genotype %>% as.character()

#replace the `genotype` string `w1118` with the string `control`
pData(eset_mini)$genotype <- pData(eset_mini)$genotype %>% str_replace("w1118", "control")

#replace the other `genotype` strings not matching the string 'control' using the lookahead regex (?!__)
pData(eset_mini)$genotype <- pData(eset_mini)$genotype %>% str_replace("^(?!control)(.*)$", "test")

#convert the `genotype` column  back to a factor vecor
pData(eset_mini)$genotype <- pData(eset_mini)$genotype %>% as.factor()

```

## Model formula 1: Group-means parametrization 
The design formulae for multi-factorial experiments can be written using any type of parametrization:  treatment-contrast, group-means, or sum-to-zero parametrization. According to the `limma` user manual (Section 9.5.4), only the names of the coeffcients in the model objects called `fit` will differ, "all components of [model objects called] `fit2` will be identical regardless of parametrization used".

Build the design matrix using the group-means prametrization. To do so combine all the varaibles of interest, `sex`, `generation` and `genotype`, into a single variable called `group`. The variable `day` holds the replicates and it should automatically get averaged within each `generation`.
```{r group_means_interaction}
# Create single variable "group"
group <- with(pData(eset_mini), 
              paste(generation,
                    genotype, 
                    sex,
                    # day,
                    sep = "."))

pData(eset_mini)$group <- as.factor(group)
remove(group)

# Create design matrix with group-means parametrization (no intercept)
design_1 <- model.matrix(~ 0 
                         # + day 
                         + group, data = pData(eset_mini))
colnames(design_1) <- levels(pData(eset_mini)$group)
colnames(design_1)

# Count the number of samples modeled by each coefficient
colSums(design_1)

#estimate the correlation between measurements made on the same repliactes:
corfit_1 <- duplicateCorrelation(eset_mini, design_1, block =  pData(eset_mini)$replicate)
corfit_1$consensus

#fit the linear model fit_model_1 with blocking
fit_model_1 <- lmFit(eset_mini, design_1, 
                     block =  pData(eset_mini)$replicate, 
                     correlation = corfit_1$consensus)

# #fit the linear model fit_model_1 without blocking
# fit_model_1 <- lmFit(eset_mini, design_1)

#####
## Build the contrasts matrix for discovering main effect of genotype in females

# 1. t-test for main effect of genotype; the following two formulations are algebraically equal;
# first tests if the difference in heights of genotype lines running across generation levels is !0
# second tests if difference(s) in heights of genotype line segments at all gen levels average to !0
# average(f1.test + f2.test + f3.test) - average (f1.control + f.2 control + f3.control)
# average[(f1.test - f1.control); (f2.test - f.2 control); (f3.test - f3.control)]

# cm_1_genotype <- makeContrasts(
#   t_v_c = (F1.test.female + F2.test.female + F3.test.female)/3 - 
#           (F1.control.female + F2.control.female + F3.control.female)/3,
#   levels = design_1)
# 
# cm_1_genotype 

## use the following contrast if predictor in the design matrix is genotype instead of group
# cm_1_genotype <- makeContrasts(
#   t_v_c = test-control,
#   levels = design_1)
# 
# cm_1_genotype

# 2. ANOVA for simple effect of genotype; compute generation-wise genotypic differences then do ANOVA;
# it tests if the difference(s) in heights of genotype line segments at any generation level are !0
# it estimates the simple effect of genotype at each level of generation

cm_1_genotype_simple <- makeContrasts(
  gen_1_geno = (F1.test.female - F1.control.female),
  gen_2_geno = (F2.test.female - F2.control.female),
  gen_3_geno = (F3.test.female - F3.control.female),
  levels = design_1)

cm_1_genotype_simple

#filter out probes with an average expression level below 3
keep <- fit_model_1$Amean > 3 #`Amean` stores the average log expression values
fit2_model_1 <- fit_model_1[keep, ] 
nrow(fit2_model_1)

#fit the contrast matrix
fit2_model_1 <- contrasts.fit(fit2_model_1, cm_1_genotype_simple)

#set trend = TRUE  since the data do not show a uniform variance across all expression intensities (this trend in the variance at different mean intensities is discovered with `plotSA(fit_model)` ) 
fit2_model_1 <- eBayes(fit2_model_1, 
                       trend = TRUE, #accommodates a mean-variance trend; 
                       robust = TRUE #increases power for some kinds of studies
                       ) 

#Results of all contrasts simultaneously
results_1_geno <- decideTests(fit2_model_1)
summary(results_1_geno)

# #Venn diagram showing numbers of genes significant in all contrasts, simultaneously
vennDiagram(results_1_geno)

#A list of top genes differentially expressed in a contarst can be obtained by specifying its coef
# topTable(fit2_model_1, coef=c(1:3), adjust="BH", number = 30)
top_1_geno_1 <- topTable(fit2_model_1,
                  coef=c(1),
                  adjust="BH", number = nrow(fit2_model_1), sort.by = "none")

top_1_geno_2 <- topTable(fit2_model_1,
                  coef=c(2),
                  adjust="BH", number = nrow(fit2_model_1), sort.by = "none")

top_1_geno_3 <- topTable(fit2_model_1,
                  coef=c(3),
                  adjust="BH", number = nrow(fit2_model_1), sort.by = "none")


hist(top_1_geno_1$P.Value)
hist(top_1_geno_2$P.Value)
hist(top_1_geno_3$P.Value)

# qplot(top_1_geno$P.Value,
#       geom="histogram",
# # specify the size of the class interval
#       binwidth = 0.05,
# # specify if bin boundaries fall at centre or ends of class intervals
#       boundary = 0.05) + ylim(0, 800) + 
#   ggtitle("p-value histogram of group-means interaction model") +
#   theme_classic()

# ggplot(data = top_1, aes(x = top_1$P.Value)) +
#   geom_histogram() +
#   xlab("p-value") +
#   ggtitle("p-value histogram of F2:F3 interaction", subtitle = "group-means model") +
#   thekme_classic() +
#   theme(plot.title = element_text(hjust = 0.5, vjust = -1),
#         plot.subtitle = element_text(hjust = 0.5, vjust = -1))

#####
## Build the contrasts matrix for discovering main effect of generation in females

# 1. ANOVA for main effect of generation; the following two formulations are algebraically equal;
# it tests if the sums of genotype line segments are at different heights at any generation level
# first average genotypes within a generation, repeat this for another generation, and then compute differece between the averages. This method is used below.
# first compute the difference between two generations and then average the differences, example: gen_2v1 = (F2.test.female - F1.test.female)/2 + (F2.control.female - F1.control.female)/2

cm_1_generation <- makeContrasts(
  gen_2v1 = (F2.test.female + F2.control.female)/2 - (F1.test.female + F1.control.female)/2,
  gen_3v1 = (F3.test.female + F3.control.female)/2 - (F1.test.female + F1.control.female)/2,
  gen_3v2 = (F3.test.female + F3.control.female)/2 - (F2.test.female + F2.control.female)/2,
  levels = design_1)

cm_1_generation

# # use the following contrast if predictor in the design matrix is generation instead of group
# cm_1_generation <- makeContrasts(
#   gen_2v1 = F2-F1,
#   gen_3v1 = F3-F1,
#   gen_3v2 = F3-F2,
#   levels = design_1)
# 
# cm_1_generation 

# 2. ANOVA for simple effect of generation; compute genotype-wise differences in slopes;
# it tests if the slopes of between-generation line segments for a specific genotype are !0
# it estimates the simple effect of generation for a specific genotype

# cm_1_generation_simple_t <- makeContrasts(
#   gen_2v1_t = (F2.test.female - F1.test.female),
#   gen_3v1_t = (F3.test.female - F1.test.female),
#   gen_3v2_t = (F3.test.female - F2.test.female),
#   levels = design_1)
#
# cm_1_generation_simple_t

cm_1_generation_simple_c <- makeContrasts(
  gen_2v1_c = (F2.control.female - F1.control.female),
  gen_3v1_c = (F3.control.female - F1.control.female),
  gen_3v2_c = (F3.control.female - F2.control.female),
  levels = design_1)

cm_1_generation_simple_c

#re-formulate fit2
keep <- fit_model_1$Amean > 3 #`Amean` stores the average log expression values
fit2_model_1 <- fit_model_1[keep, ] 
nrow(fit2_model_1)

#fit the contrast matrix
fit2_model_1 <- contrasts.fit(fit2_model_1, cm_1_generation)

fit2_model_1 <- eBayes(fit2_model_1, 
                       trend = TRUE, #accommodates a mean-variance trend; 
                       robust = TRUE #increases power for some kinds of studies
                       )

#Results of all contrasts simultaneously
results_1_gener <- decideTests(fit2_model_1)
summary(results_1_gener)

#Venn diagram showing numbers of genes significant in all contrasts, simultaneously
vennDiagram(results_1_gener)

#A list of top genes differentially expressed in a contarst can be obtained by specifying its coef
top_1_gener <- topTable(fit2_model_1,
                  # coef=c(1:2),
                  adjust="BH", number = nrow(fit2_model_1), sort.by = "none")

hist(top_1_gener$P.Value)

qplot(top_1_gener$P.Value,
      geom="histogram",
      binwidth = 0.05,
      boundary = 0.05) + ylim(0, 800) + 
  ggtitle("p-value histogram of group-means interaction model") +
  theme_classic()

#####
## Build the contrasts matrix for discovering interaction in females

# it tests if  differences in genotype line segments are at different heights at any generation level
cm_1_interaction  <- makeContrasts(
  # gen_1v0 = (F1.test.female-F0.test.female) - (F1.control.female-F0.control.female),
  gen_2v1 = (F2.test.female-F1.test.female) - (F2.control.female-F1.control.female),
  gen_3v1 = (F3.test.female-F1.test.female) - (F3.control.female-F1.control.female),
  gen_3v2 = (F3.test.female-F2.test.female) - (F3.control.female-F2.control.female),
  levels = design_1)

cm_1_interaction 

#Build the contrasts matrix for discovering interaction in males

# contrast_matrix_1 <- makeContrasts(
#   # gen_1v0 = (F1.test.male-F0.test.male) - (F1.control.male-F0.control.male),
#   gen_2v1 = (F2.test.male-F1.test.male) - (F2.control.male-F1.control.male),
#   gen_3v2 = (F3.test.male-F2.test.male) - (F3.control.male-F2.control.male),
#   gen_3v1 = (F3.test.male-F1.test.male) - (F3.control.male-F1.control.male),
#   levels = design_1)
# contrast_matrix_1

#re-formulate fit2
keep <- fit_model_1$Amean > 3 #`Amean` stores the average log expression values
fit2_model_1 <- fit_model_1[keep, ] 
nrow(fit2_model_1)

#fit the contrast matrix
fit2_model_1 <- contrasts.fit(fit2_model_1, cm_1_interaction)

fit2_model_1 <- eBayes(fit2_model_1, 
                       trend = TRUE, #accommodates a mean-variance trend; 
                       robust = TRUE #increases power for some kinds of studies
                       ) 

#Results of all contrasts simultaneously
results_1_inter <- decideTests(fit2_model_1)
summary(results_1_inter)

#Venn diagram showing numbers of genes significant in all contrasts, simultaneously
vennDiagram(results_1_inter)

#A list of top genes differentially expressed in a contarst can be obtained by specifying its coef
top_1_inter <- topTable(fit2_model_1,
                  # coef=c(1:2),
                  adjust="BH", number = nrow(fit2_model_1), sort.by = "none")

hist(top_1_inter$P.Value)

qplot(top_1_inter$P.Value,
      geom="histogram",
      binwidth = 0.05,
      boundary = 0.05) + ylim(0, 800) + 
  ggtitle("p-value histogram of group-means interaction model") +
  theme_classic()
```

## Model formula 2: full interaction 
```{r full_interaction}
design_2 <- model.matrix(~ genotype*generation, data = pData(eset_mini))

colnames(design_2)

# Count the number of samples modeled by each coefficient
colSums(design_2)

#estimate the correlation between measurements made on the same repliactes:
corfit_2 <- duplicateCorrelation(eset_mini, design_2, block =  pData(eset_mini)$replicate)
corfit_2$consensus

#fit the linear model fit_model_2 with blocking
fit_model_2 <- lmFit(eset_mini, design_2, block =  pData(eset_mini)$replicate, correlation = corfit_2$consensus)

# #fit the linear model fit_model_2 without blocking
# fit_model_2 <- lmFit(eset_mini, design_2)

#fit the contrast matrix
# fit2_model_2 <- contrasts.fit(fit_model_2, contrast_matrix_2)

#filter out probes with an average expression level below 3
#set trend = TRUE  since the data do not show uniform a variance across all expression intensities (this trend in the variance at different mean intensities is discovered with `plotSA(fit_model)` ) 

keep <- fit_model_2$Amean > 3 #`Amean` stores the average log expression values
fit2_model_2 <- fit_model_2[keep, ] 
nrow(fit2_model_2)

#build the contrast matrix
cm_2_inter  <- bind_cols(
  # gen_1v0 = (F1.test.female-F0.test.female) - (F1.control.female-F0.control.female),
  gen_2v1 = c(0,0,0,0,1,0),
  gen_3v1 = c(0,0,0,0,0,1),
  gen_3v2 = c(0,0,0,0,-1,1),
  )

cm_2_interaction 

#fit the contrast matrix
fit2_model_2 <- contrasts.fit(fit2_model_2, cm_2_interaction)


fit2_model_2 <- eBayes(fit2_model_2,
                       trend = TRUE, #accommodates a mean-variance trend; 
                       robust = TRUE #increases power for some kinds of studies
                       ) 

#Results of all contrasts simultaneously
results_2_inter <- decideTests(fit2_model_2)
summary(results_2_inter)

#Venn diagram showing numbers of genes significant in all contrasts, simultaneously
# vennDiagram(object = results_2[ , c(5,6)], names = c("gen_2v1", "gen_3v1"))
vennDiagram(results_2_inter)

# #A list of top genes differentially expressed in a contarst can be obtained by specifying its coef
# topTable(fit2_model_2, adjust="BH", number = 30)
top_2_inter <- topTable(fit2_model_2, 
                  # coef = c(5:6), 
                  adjust = "BH", number = nrow(fit2_model_2), sort.by = "none")

hist(top_2_inter$P.Value)

qplot(top_2_inter$P.Value,
      geom="histogram",
# specify the size of the class interval
      binwidth = 0.05,
# specify if bin boundaries fall at centre or ends of class intervals
      boundary = 0.05) + ylim(0, 800) + 
  ggtitle("p-value histogram of nested interaction model") + 
  theme_classic()
```

## Model formula 3: classic interaction 
```{r classic_interaction}
# design_3.1 <- model.matrix(~ day + genotype*generation, data = pData(eset_mini))
# intercept column present (all groups); day1, genotype control, and generation F2 absent

design_3 <- model.matrix(~ 
                           # day + 
                           genotype + generation, data = pData(eset_mini))

colnames(design_3)

# Count the number of samples modeled by each coefficient
colSums(design_3)

#Testing the contrasts/hypotheses

#estimate the correlation between measurements made on the same repliactes:
corfit_3 <- duplicateCorrelation(eset_mini, design_3, block =  pData(eset_mini)$replicate)
corfit_3$consensus

#fit the linear model fit_model_3 with blocking
fit_model_3 <- lmFit(eset_mini, design_3, 
                     block =  pData(eset_mini)$replicate, 
                     correlation = corfit_3$consensus
                     )

#####
# Build the contrasts matrix for discovering main effect of genotype in females
cm_3_geno  <- c(0,1,0,0)
cm_3_geno 

#filter out probes with an average expression level below 3
keep <- fit_model_3$Amean > 3 #`Amean` stores the average log expression values
fit2_model_3 <- fit_model_3[keep, ]
nrow(fit2_model_3)

#fit the contrast matrix
fit2_model_3 <- contrasts.fit(fit2_model_3, cm_3_geno)

#set trend = TRUE  since the data do not show uniform a variance across all expression intensities (this trend in the variance at different mean intensities is discovered with `plotSA(fit_model)` )
fit2_model_3 <- eBayes(fit2_model_3, 
                       trend = TRUE, #accommodates a mean-variance trend; 
                       robust = TRUE #increases power for some kinds of studies
                       ) 

#Results of all contrasts simultaneously
results_3_geno <- decideTests(fit2_model_3)
summary(results_3_geno)

# #Venn diagram showing numbers of genes significant in the last two coefficients
# vennDiagram(object = results_3_geno)

#A list of top genes differentially expressed in a contarst can be obtained by specifying its coef
top_3_geno <- topTable(fit2_model_3,
                  # coef = c(2),
                  adjust = "BH", number = nrow(fit2_model_3), sort.by = "none")

hist(top_3_geno$P.Value)

qplot(top_3_geno$P.Value,
      geom="histogram",
# specify the size of the class interval
      binwidth = 0.05,
# specify if bin boundaries fall at centre or ends of class intervals
      boundary = 0.05) + ylim(0, 800) + 
  ggtitle("p-value histogram of additive model") +
  theme_classic()

#####
#re-formulate fit2
keep <- fit_model_3$Amean > 3 #`Amean` stores the average log expression values
fit2_model_3 <- fit_model_3[keep, ]
nrow(fit2_model_3)

#build the contrast matrix
cm_3_gener  <- bind_cols(
  # gen_1v0 = (F1.test.female-F0.test.female) - (F1.control.female-F0.control.female),
  gen_2v1 = c(0,0,1,0),
  gen_3v1 = c(0,0,0,1),
  gen_3v2 = c(0,0,-1,1),
  )

cm_3_gener 

#fit the contrast matrix
fit2_model_3 <- contrasts.fit(fit2_model_3, cm_3_gener)

fit2_model_3 <- eBayes(fit2_model_3, 
                       trend = TRUE, #accommodates a mean-variance trend; 
                       robust = TRUE #increases power for some kinds of studies
                       ) 

#Results of all contrasts simultaneously
results_3_gener <- decideTests(fit2_model_3)
summary(results_3_gener)

# #Venn diagram showing numbers of genes significant in the last two coefficients
# vennDiagram(object = results_3[ , c(3,4)], names = c("gen_2v1", "gen_3v1"))
vennDiagram(results_3_gener)

#A list of top genes differentially expressed in a contarst can be obtained by specifying its coef
top_3_gener <- topTable(fit2_model_3,
                  # coef = c(3:4),
                  adjust = "BH", number = nrow(fit2_model_3), sort.by = "none")

hist(top_3_gener$P.Value)

qplot(top_3_gener$P.Value,
      geom="histogram",
# specify the size of the class interval
      binwidth = 0.05,
# specify if bin boundaries fall at centre or ends of class intervals
      boundary = 0.05) + ylim(0, 800) + 
  ggtitle("p-value histogram of additive model") +
  theme_classic()
```

## Model formula 4: sum to zero
```{r sum_to_zero}
genotype <- pData(eset_mini)$genotype
generation <- pData(eset_mini)$generation
contrasts(genotype) <- contr.sum(2)
contrasts(generation) <- contr.sum(3)
design_4 <- model.matrix(~genotype*generation)
remove(generation, genotype)

colnames(design_4)

corfit_4 <- duplicateCorrelation(eset_mini, design_4, block =  pData(eset_mini)$replicate)
corfit_4$consensus

#fit the linear model fit_model_3 with blocking
fit_model_4 <- lmFit(eset_mini, design_4, 
                     block =  pData(eset_mini)$replicate, 
                     correlation = corfit_4$consensus
                     )

#####
# Build the contrasts matrix for discovering main effect of genotype in females
cm_4_geno  <- c(0,-1,0,0,0,0)
cm_4_geno 

#filter out probes with an average expression level below 3
keep <- fit_model_4$Amean > 3 #`Amean` stores the average log expression values
fit2_model_4 <- fit_model_4[keep, ]
nrow(fit2_model_4)

#fit the contrast matrix
fit2_model_4 <- contrasts.fit(fit2_model_4, cm_4_geno)

fit2_model_4 <- eBayes(fit2_model_4, 
                       trend = TRUE, #accommodates a mean-variance trend; 
                       robust = TRUE #increases power for some kinds of studies
                       )

#Results of all contrasts simultaneously
results_4_geno <- decideTests(fit2_model_4)
summary(results_4_geno)

# #Venn diagram showing numbers of genes significant in the last two coefficients
# vennDiagram(results_4_geno)

#A list of top genes differentially expressed in a contarst can be obtained by specifying its coef
top_4_geno <- topTable(fit2_model_4,
                  # coef = c(2),
                  adjust = "BH", number = nrow(fit2_model_4), sort.by = "none")

hist(top_4_geno$P.Value)

qplot(top_4_geno$P.Value,
      geom="histogram",
# specify the size of the class interval
      binwidth = 0.05,
# specify if bin boundaries fall at centre or ends of class intervals
      boundary = 0.05) + ylim(0, 800) + 
  ggtitle("p-value histogram of classic interaction model") +
  theme_classic()

#####
# Build the contrasts matrix for discovering main effect of generation in females
cm_4_gener  <- bind_cols(
  # gen_1v0 = (F1.test.female-F0.test.female) - (F1.control.female-F0.control.female),
  gen_2v1 = c(0,	0,	-1,	 1,	0,	0),
  gen_3v1 = c(0,	0,	-2,	-1,	0,	0),
  gen_3v2 = c(0,	0,	-1,	-2,	0,	0)
  )

cm_4_gener 

# # use the following matrix for getting FC values within generation instead of across generation
# cm_4_gener  <- bind_cols(
#   gener_1 = c(1,	0,	1,	0,	0,	0),
#   gener_2 = c(1,	0,	0,	1,	0,	0),
#   gener_3 = c(1,	0, -1, -1,	0,	0)
#   )
# 
# cm_4_gener

#filter out probes with an average expression level below 3
keep <- fit_model_4$Amean > 3 #`Amean` stores the average log expression values
fit2_model_4 <- fit_model_4[keep, ]
nrow(fit2_model_4)

#fit the contrast matrix
fit2_model_4 <- contrasts.fit(fit2_model_4, cm_4_gener)

fit2_model_4 <- eBayes(fit2_model_4, 
                       trend = TRUE, #accommodates a mean-variance trend; 
                       robust = TRUE #increases power for some kinds of studies
                       )

#Results of all contrasts simultaneously
results_4_gener <- decideTests(fit2_model_4)
summary(results_4_gener)

#Venn diagram showing numbers of genes significant in the last two coefficients
vennDiagram(results_4_gener)

#A list of top genes differentially expressed in a contarst can be obtained by specifying its coef
top_4_gener <- topTable(fit2_model_4,
                  # coef = c(3:4),
                  adjust = "BH", number = nrow(fit2_model_4), sort.by = "none")

hist(top_4_gener$P.Value)

qplot(top_4_gener$P.Value,
      geom="histogram",
# specify the size of the class interval
      binwidth = 0.05,
# specify if bin boundaries fall at centre or ends of class intervals
      boundary = 0.05) + ylim(0, 800) + 
  ggtitle("p-value histogram of classic interaction model") +
  theme_classic()

#####
#Build the contrasts matrix for discovering interaction in females
cm_4_inter <- bind_cols(
  # gen_1v0 = (F1.test.female-F0.test.female) - (F1.control.female-F0.control.female),
  gen_2v1 = c(0,0,0,0,1,-1),
  gen_3v1 = c(0,0,0,0,2,1),
  gen_3v2 = c(0,0,0,0,1,2),
  )

cm_4_inter 

#filter out probes with an average expression level below 3
keep <- fit_model_4$Amean > 3 #`Amean` stores the average log expression values
fit2_model_4 <- fit_model_4[keep, ]
nrow(fit2_model_4)

#fit the contrast matrix
fit2_model_4 <- contrasts.fit(fit2_model_4, cm_4_inter)

fit2_model_4 <- eBayes(fit2_model_4, 
                       trend = TRUE, #accommodates a mean-variance trend; 
                       robust = TRUE #increases power for some kinds of studies
                       ) 

#Results of all contrasts simultaneously
results_4_inter <- decideTests(fit2_model_4)
summary(results_4_inter)

#Venn diagram showing numbers of genes significant in the last two coefficients
vennDiagram(results_4_inter)

#A list of top genes differentially expressed in a contarst can be obtained by specifying its coef
top_4_inter <- topTable(fit2_model_4,
                  # coef = c(5:6),
                  adjust = "BH", number = nrow(fit2_model_4), sort.by = "none")

hist(top_4_inter$P.Value)

qplot(top_4_inter$P.Value,
      geom="histogram",
# specify the size of the class interval
      binwidth = 0.05,
# specify if bin boundaries fall at centre or ends of class intervals
      boundary = 0.05) + ylim(0, 800) + 
  ggtitle("p-value histogram of classic interaction model") +
  theme_classic()
```

```{r}

# decideTests() and vennDiagram() are only useful for comparing contrasts present within a model
# to check the overlap between models look at the intersection of their respective topTable() outputs

# when coef() is used to combine two or more contrasts, then only topTable() output is useful

intersect(rownames(top_1_gener[top_1_gener$adj.P.Val <= 0.05, ]), rownames(top_4_gener[top_4_gener$adj.P.Val <= 0.05, ])) %>% length()

rownames(top_1_gener[top_1_gener$adj.P.Val <= 0.05, ]) %>% length()

rownames(top_4_gener[top_4_gener$adj.P.Val <= 0.05, ]) %>% length()


intersect(rownames(top_1_inter[top_1_inter$adj.P.Val <= 0.05, ]), rownames(top_4_inter[top_4_inter$adj.P.Val <= 0.05, ]))  %>% length()

rownames(top_1_inter[top_1_inter$adj.P.Val <= 0.05, ]) %>% length()

rownames(top_4_inter[top_4_inter$adj.P.Val <= 0.05, ]) %>% length()
```


## Empirical null distributions
The function `frdtool()` accepts a vector of z-scores, correlations, p-values, or t-scores as input and estimates the parameters of the corresponding null distribution empirically from the data (except in the case of p-values, where it's unnecessary). 
The kind of null distirbution to be estimated is specified by the argument `statistic`. 
The author of the package suggests setting `statistic = "normal"` (as opposed to `statistic = "studentt"`) [even when the input is a vector of t-scores"](https://stackoverflow.com/questions/25810435/r-fdrtool-package-how-to-use-t-statistic). 

The null distribution is assumed to be centred at zero, as stated in the [fdrtool manual](https://cran.r-project.org/web/packages/fdrtool/fdrtool.pdf).
Hence, the column of t-statstics in the output of `topTable()` will first be median-centered and then piped into `fdrtool()`.
```{r empirical_null}
library(fdrtool)

# Using t-statistics as input

## group-means interaction model

fdr_1_1 <- (top_1_geno_1$t - median(top_1_geno$t)) %>% fdrtool(statistic= "normal", plot = F)
fdr_1_2 <- (top_1_geno_2$t - median(top_1_geno$t)) %>% fdrtool(statistic= "normal", plot = F)
fdr_1_3 <- (top_1_geno_3$t - median(top_1_geno$t)) %>% fdrtool(statistic= "normal", plot = F)


qplot(fdr_1_1$pval, geom="histogram", binwidth = 0.05, boundary = 0.05, color = I("black"), fill = I(NA)) + ggtitle("p-value histogram of group-means interaction model, corrected (via t-stats)") +
  theme_classic() +
  xlab("corrected p-values") + ylim(0, 1250) 

qplot(fdr_1_2$pval, geom="histogram", binwidth = 0.05, boundary = 0.05, color = I("black"), fill = I(NA)) + ggtitle("p-value histogram of group-means interaction model, corrected (via t-stats)") +
  theme_classic() +
  xlab("corrected p-values") + ylim(0, 1250) 

qplot(fdr_1_3$pval, geom="histogram", binwidth = 0.05, boundary = 0.05, color = I("black"), fill = I(NA)) + ggtitle("p-value histogram of group-means interaction model, corrected (via t-stats)") +
  theme_classic() +
  xlab("corrected p-values") + ylim(0, 1250) 

## nested interaction model

fdr_2 <- (top_2$t - median(top_2$t)) %>% fdrtool(statistic= "normal", plot = F)

qplot(fdr_2$pval, geom="histogram", binwidth = 0.05, boundary = 0.05, color = I("black"), fill = I(NA)) + ggtitle("p-value histogram of nested interaction model, corrected (via t-stats)") +
  theme_classic() +
  xlab("corrected p-values") + ylim(0, 1250) 

## classic interaction model
fdr_3 <- (top_3$t - median(top_3$t)) %>% fdrtool(statistic= "normal", plot = F)

qplot(fdr_3$pval, geom="histogram", binwidth = 0.05, boundary = 0.05, color = I("black"), fill = I(NA)) + ggtitle("p-value histogram of classic interaction model, corrected (via t-stats)") +
  theme_classic() +
  xlab("corrected p-values") + ylim(0, 1250) 


# # using p-values as input
# 
# ## group-means interaction model
# fdr_1.2 <- top_1$P.Value %>% fdrtool(statistic = "pvalue", plot = F)
# 
# qplot(fdr_1.2$pval, geom="histogram") +
#   ggtitle("p-value histogram of group-means interaction model, corrected (via p-values)") +
#   theme_classic() +
#   xlab("corrected p-values")
# 
# ## classic interaction model
# fdr_3.2 <- top_3$P.Value %>% fdrtool(statistic= "pvalue", plot = F)
# 
# qplot(fdr_3.2$pval, geom="histogram") +
#   ggtitle("p-value histogram of classic interaction model, corrected (via p-values)") +
#   theme_classic() +
#   xlab("corrected p-values")

```

```{r p_value_loop, eval = FALSE}
# plot p-value histograms of each ExpressionSet objects containing probes of different intensities 

for(i in seq_along(1:15)){
  
# Create single variable
group <- with(pData(eset_list[[i]]), paste(generation, genotype, sex, day, sep = "."))
pData(eset_list[[i]])$group <- as.factor(group)

# Create design matrix with group-means parametrization (no intercept)
design_1 <- model.matrix(~ 0 + group, data = pData(eset_list[[i]]))
colnames(design_1) <- levels(pData(eset_list[[i]])$group)

#Build the contrasts matrix for females
contrast_matrix_1 <- makeContrasts(
# gen_1v0 = (F1.test.female-F0.test.female) - (F1.control.female-F0.control.female),
# gen_2v1 = (F2.test.female-F1.test.female) - (F2.control.female-F1.control.female),
gen_3v2 = (
  (#(F3.test.female.1-F2.test.female.1) +
             # (F3.test.female.2-F2.test.female.2) +
             (F3.test.female.3-F2.test.female.3))
#           /2)
- (
  (
    #(F3.control.female.1-F2.control.female.1) +
                                                         # (F3.control.female.2-F2.control.female.2) +
                                                         (F3.control.female.3-F2.control.female.3))
#  /2)
,
# gen_3v1 = (F3.test.female-F1.test.female) - (F3.control.female-F1.control.female),
                                  levels = design_1)

fit_model_1 <- lmFit(eset_list[[i]], design_1)
fit2_model_1 <- contrasts.fit(fit_model_1, contrast_matrix_1)
fit2_model_1 <- eBayes(fit2_model_1)
top_1 <- topTable(fit2_model_1, adjust="BH", number = nrow(fit2_model_1), sort.by = "none")
hist(top_1$P.Value, breaks = 100, xlim = c(0,1),
      main = str_glue("p-value histogram of probes with intensities above {i} rma"))
}
```

```{r venn_overlap}
venn_overlap <- results_1@.Data %>% subset(results_1@.Data[ , "gen_2v1"] != 0 & 
                     results_1@.Data[ , "gen_3v1"] != 0) %>% 
                      rownames()

sig_F <- top_1 %>% subset(adj.P.Val <= 0.05) %>% rownames()

venn_overlap 
sig_F 

#boxplot of all the groups pf gene i in the list sig_F
boxplot(exprs(eset_mini)[sig_F[i], ] ~ pData(eset_mini)[ , "group"])

ggplot(data = pData(eset_mini), aes(x = generation, exprs(eset_mini)[sig_F[29], ], fill=genotype)) +
  # geom_point(aes(col = genotype), position = position_jitter(0.1), shape = 1, size = 5) +
  geom_dotplot(position = position_jitter(0.1), binaxis = "y", stackdir = "center", alpha = 0.7) +
  theme_classic()
```

#
> conclusions based on boxplots (code above)
1. topTable() puts out ANOVA F-values where applicable because its unsorted `P.Val` and `F.p.value` obtained from the `fit2` model objects are the same. 
2. The 29 genes whose adj.P.Val <= 0.05 in topTable are the same as the 28 genes that overlap in the Venn diagram between gen_2v1 and gen_3v1, only probe 1626202_at differs.
3. In boxplots of all these 28 probes (stored in item `sig_F`) only the F1 generation test genotype differs from the other groups; the F1 control and F2 tests and controls cluster together along the Y-axis. It's likely that many other probes also show this pattern, but the F1 test deviation of only these 28 probes is large enough to register as an intercation effect (visual metaphor: the F1 test pulls the test trendline so far away at generation timepoint 1, that the overall test trendline is calculated to be different from the overall control line for these 28 probes.).
4. Compare a simple model with just the main effect of generation with a complex model including both the main effect and the interaction to see if the interaction is driven completely by the main effect.
5. Perform Tukey pairwise comparison **between** the three contrasts of the interaction to discover which one is significant
6. Similarly perform Tukey pairwise comparison **within** the three contrasts of the main effcet of gneration to discover which one is significant
7. check p-value histgrams of main  effects

> check if including any of the following steps imporves the shape of p-value hists [done]
7. remove the three largest sources of variation **before** RMA/GCRMA (sex, generation, & L9F2) [done]
8. Include more variables in the model [done; included the variable `replicate`]
9. remove both low **and** high intensity probes (ie remove humps from both sides) [done]

> refresher
* subsetting with square brackets returns a data frame and subsetting with $ returns a vector
* one cannot pipe through row names to the downstream steps after either filtering or subsetting
* Search Datacamp courses (listed in Google Keep) to make ggplot versions of the plots.

# Acknowledgements
(Incorporate these acknowledgements into the references)
This content was developed by heavily modifying content from [VIB Bioinformatics Core Wiki](https://wiki.bits.vib.be/index.php/Analyze_your_own_microarray_data_in_R/Bioconductor) and [@Klaus2019]

(Correct the terminology for the variables. Check out https://www.theanalysisfactor.com/whats-in-a-name-moderation-and-interaction-predictor-and-predictor-variables/)

***

# References


